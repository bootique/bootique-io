<!doctype html>
<html class="no-js" lang="en-us">
<head>
  <meta charset="utf-8">

  <title>Bootique Core Documentation - v3</title>
  <meta name="description" content="Discover Bootique Core v3: Your guide to building Java applications with advanced modularity, DI, and configuration for microservices and more.">
  <meta name="keywords" content="bootique, bootique core, java framework, version 3.0">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="manifest" href="/images/favicon/site.webmanifest">
  <link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#333333">
  <link rel="shortcut icon" href="/images/favicon/favicon.ico">
  <link rel="me" href="https://mastodon.social/@andrus_a"/>
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-config" content="/images/favicon/browserconfig.xml">
  <meta name="theme-color" content="#333333">
  <link rel="canonical" href="https://bootique.io/docs/3.x/bootique-docs/">
  <link href="/assets/app.css?0feb24357c49235eff59" rel="stylesheet">
<script type="text/javascript" src="/assets/app.js?0feb24357c49235eff59"></script>

</head>

<body data-spy="scroll" data-target="#docs-nav">

<!--[if lt IE 10]>
<p class="browsehappy">
  You are using an <strong>outdated</strong> browser.
  Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.
</p>
<![endif]-->

<div id="top-nav" class="main">
  
  <a href="#menu" id="menuToggle" aria-label="Menu" class="menu-toggle">
      <span></span>
  </a>
  <div id="menu" class="nav-menu pure-menu pure-menu-horizontal">
    <a href="https://bootique.io/" class="nav-brand center"><img src="/images/logo.svg" alt="Bootique" /></a>
    <div class="container nav">
      <div class="valign-wrapper-sm">
        <div class="valign-sm">
          <ul class="pure-menu-list pull-left">
    
    
        <li class="pure-menu-item "><div class="">
            
              <a class="pure-menu-link" href="/docs/3.x/getting-started/">Get started</a>
            
            </div>
        </li>
  
        <li class="pure-menu-item "><div class="pure-menu-selected">
            <a class="pure-menu-link" href="/docs/3.x">Documentation</a>
          </div>
        </li>
  
        <li class="pure-menu-item ">
          <a class="pure-menu-link" href="/cla/">CLA</a>
        </li>
  
        <li class="pure-menu-item ">
          <a class="pure-menu-link" href="https://groups.google.com/forum/#!forum/bootique-user">Forum</a>
        </li>
  
</ul>

        </div>
      </div>
      <ul id="nav-social" class="pure-menu-list pull-right">
        <li class="pure-menu-item gh-btns" data-gh-owner="bootique" data-gh-repo="bootique">
          <a href="https://github.com/bootique/bootique" class="pure-menu-link github-btn fork">
            <i class="fab fa-github"></i><span>Github</span>
          </a>
          <a href="https://github.com/bootique/bootique/stargazers" class="pure-menu-link github-btn star">
            <img class="gh-stars" src="/images/icon_octocat_stars.svg" alt="GitHub Stars" />
            <span class="star-counter">1417</span>
          </a>
        </li>
        <li class="pure-menu-item tw-btn">
          <a href="https://twitter.com/intent/follow?screen_name=BootiqueProject" class="pure-menu-link tw-btn">
            <i class="fab fa-twitter"></i><span>Follow</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</div>


<div class="documentation-page container content docbook">
  <div class="container">
    <h1>
      Bootique Core - v3.0
    </h1>
    <div class="dropdown doc-version">
  <a class="dropdown-toggle" href="#" id="dropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" data-offset="-24,4">
      Version 3.0
  </a>
  <div class="dropdown-menu" aria-labelledby="dropdownMenuLink">
          
              <a class="dropdown-item active" href="/docs/3.x/bootique-docs/">Version 3.0 (alpha)</a>
          
          
              <a class="dropdown-item " href="/docs/2.x/bootique-docs/">Version 2.0 (stable)</a>
          
          
              <a class="dropdown-item " href="/docs/1.x/bootique-docs/">Version 1.3 (old)</a>
          </div>
</div>

    <hr/>

    <div class="row ">
      <div id="docs-nav" class="col-12 col-lg-4 col-xl-3 nav  docs-nav"><div id="toc" class="toc toc-side">
 <div id="toctitle">
  Table of Contents
 </div>
 <ul class="sectlevel1 nav">
  <li><a href="#_overview" class="nav-link">1. Overview</a>
   <ul class="sectlevel2 nav">
    <li><a href="#_what_is_bootique" class="nav-link">1.1. What is Bootique</a></li>
    <li><a href="#_java_version" class="nav-link">1.2. Java Version</a></li>
    <li><a href="#_build_system" class="nav-link">1.3. Build System</a></li>
   </ul></li>
  <li><a href="#_programming" class="nav-link">2. Programming</a>
   <ul class="sectlevel2 nav">
    <li><a href="#_modules" class="nav-link">2.1. Modules</a></li>
    <li><a href="#_objects_assembly" class="nav-link">2.2. Objects Assembly</a></li>
    <li><a href="#_configuration" class="nav-link">2.3. Configuration</a></li>
    <li><a href="#_commands" class="nav-link">2.4. Commands</a></li>
    <li><a href="#_options" class="nav-link">2.5. Options</a></li>
    <li><a href="#_logging" class="nav-link">2.6. Logging</a></li>
   </ul></li>
  <li><a href="#_testing" class="nav-link">3. Testing</a>
   <ul class="sectlevel2 nav">
    <li><a href="#_bootique_and_testing" class="nav-link">3.1. Bootique and Testing</a></li>
    <li><a href="#bqruntime" class="nav-link">3.2. Test BQRuntimes</a></li>
    <li><a href="#_test_tools_and_scopes" class="nav-link">3.3. Test Tools and Scopes</a></li>
    <li><a href="#_bqtestfactory_tool" class="nav-link">3.4. BQTestFactory Tool</a></li>
    <li><a href="#_common_test_scenarios" class="nav-link">3.5. Common Test Scenarios</a></li>
   </ul></li>
  <li><a href="#_assembly_and_deployment" class="nav-link">4. Assembly and Deployment</a>
   <ul class="sectlevel2 nav">
    <li><a href="#runnable-jar-with-dependencies" class="nav-link">4.1. Runnable Jar with Dependencies</a></li>
    <li><a href="#runnable-jar-with-lib" class="nav-link">4.2. Runnable Jar with "lib" Folder</a></li>
    <li><a href="#_tracing_bootique_startup" class="nav-link">4.3. Tracing Bootique Startup</a></li>
   </ul></li>
 </ul>
</div></div>

      <div class="col-12 col-lg-8 col-xl-9  py-3 pl-lg-5">
        <article>
          <div class="sect1">
 <h2 id="_overview">1. Overview</h2>
 <div class="sectionbody">
  <div class="sect2">
   <h3 id="_what_is_bootique">1.1. What is Bootique</h3>
   <div class="paragraph">
    <p>Bootique is a platform for building container-less runnable Java applications. It is an ideal technology for microservices, as it allows you to create a fully-functional app with minimal-to-no setup. Though it is not limited to a specific kind of application (or to the "micro" size) and can be used for REST services, webapps, runnable jobs, DB migrations, JavaFX GUI apps or really anything else.</p>
   </div>
   <div class="paragraph">
    <p>Unlike traditional container-based apps, Bootique allows you to control your <code>main()</code> method and create Java apps that behave like simple executable commands:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">java -jar my.jar [arguments]</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>Each Bootique app can be started with a YAML configuration, or configured with shell variables and is ideally suited for Docker / cloud deployments.</p>
   </div>
   <div class="paragraph">
    <p>Compared to other products in this space Bootique has a focus on modularity and clean pluggable architecture. It is built on top of a dependency injection container, and pretty much anything in Bootique can be customized/overridden to your liking.</p>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_java_version">1.2. Java Version</h3>
   <div class="paragraph">
    <p>Java 11 or newer is required.</p>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_build_system">1.3. Build System</h3>
   <div class="paragraph">
    <p>Bootique apps can be built using any Java build system (Ant, Maven, Gradle, etc). Examples in the documentation are based on Maven.</p>
   </div>
  </div>
 </div>
</div>
<div class="sect1">
 <h2 id="_programming">2. Programming</h2>
 <div class="sectionbody">
  <div class="paragraph">
   <p>The simplest "main" class in a Bootique application looks like this:</p>
  </div>
  <div class="listingblock">
   <div class="content">
    <pre class="highlight"><code class="language-java java" data-lang="java">public class Application implements BQModule {

    public static void main(String[] args) {
        Bootique.main(args);
    }

    @Override
    public void configure(Binder binder) {
        // configure services
    }
}</code></pre>
   </div>
  </div>
  <div class="paragraph">
   <p>Alternatively, if you want to customize the application structure, you can use <code>Bootique</code> builder API. Most apps would need to specify at least the following:</p>
  </div>
  <div class="listingblock">
   <div class="content">
    <pre class="highlight"><code class="language-java java" data-lang="java">public static void main(String[] args) {
    Bootique.app(args) <i class="conum" data-value="1"></i><b>(1)</b>
            .autoLoadModules() <i class="conum" data-value="2"></i><b>(2)</b>
            .exec() <i class="conum" data-value="3"></i><b>(3)</b>
            .exit(); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
   </div>
  </div>
  <div class="colist arabic">
   <table>
    <tbody>
     <tr>
      <td><i class="conum" data-value="1"></i><b>1</b></td>
      <td>Starts the builder and captures startup arguments (usually passed from the surrounding environment)</td>
     </tr>
     <tr>
      <td><i class="conum" data-value="2"></i><b>2</b></td>
      <td>Enables <a href="#modules_loading">module auto-loading</a></td>
     </tr>
     <tr>
      <td><i class="conum" data-value="3"></i><b>3</b></td>
      <td>Creates Bootique runtime and executes it. The action executed depends on the startup arguments above</td>
     </tr>
     <tr>
      <td><i class="conum" data-value="4"></i><b>4</b></td>
      <td>Exits the JVM passing the exit code to the OS</td>
     </tr>
    </tbody>
   </table>
  </div>
  <div class="paragraph">
   <p>Step 3 (the <code>exec(..)</code> method) is actually two steps combined in one for convenience. Let’s expand it further to demonstrate the <code>BQRuntime</code> object, that is the entry point of the application:</p>
  </div>
  <div class="listingblock">
   <div class="content">
    <pre class="highlight"><code class="language-java java" data-lang="java">public static void main(String[] args) {
    BQRuntime runtime = Bootique.app(args)
            .autoLoadModules()
            .createRuntime(); <i class="conum" data-value="1"></i><b>(1)</b>

    runtime.run() <i class="conum" data-value="2"></i><b>(2)</b>
            .exit();
}</code></pre>
   </div>
  </div>
  <div class="colist arabic">
   <table>
    <tbody>
     <tr>
      <td><i class="conum" data-value="1"></i><b>1</b></td>
      <td>Creates a <code>BQRuntime</code> object</td>
     </tr>
     <tr>
      <td><i class="conum" data-value="2"></i><b>2</b></td>
      <td>Executes the runtime <code>run()</code> method</td>
     </tr>
    </tbody>
   </table>
  </div>
  <div class="paragraph">
   <p><code>BQRuntime</code> holds all app objects (often called "services") created by Bootique. For all intents and purposes, <code>BQRuntime</code> <em>is</em> the "application". You can peek inside the runtime to access its objects. E.g., here we are retrieving a <code>Cli</code> instance that is defined in Bootique and describes the command line arguments our app was started with:</p>
  </div>
  <div class="listingblock">
   <div class="content">
    <pre class="highlight"><code class="language-java java" data-lang="java">Cli cli = runtime.getInstance(Cli.class);</code></pre>
   </div>
  </div>
  <div class="paragraph">
   <p>What objects exist in the runtime and how they are initialized is determined by the "modules" discovered and loaded by <code>Bootique</code>, so next let’s discuss what modules are.</p>
  </div>
  <div class="sect2">
   <h3 id="_modules">2.1. Modules</h3>
   <div class="paragraph">
    <p>A module is a class that implements <code>BQModule</code>. Modules serve as "blueprints" for Bootique to create application objects via the "bindings" API and <em>dependency injection</em> (DI).</p>
   </div>
   <div class="admonitionblock note">
    <table>
     <tbody>
      <tr>
       <td class="icon"><i class="fa fa-info-circle fa-2x" title="Note"></i></td>
       <td class="content">Colloquially, the term "modules" is also applied to <code>.jar</code> files that contain those classes together with a bunch of "regular" classes. So we will use the word interchangeably.</td>
      </tr>
     </tbody>
    </table>
   </div>
   <div class="paragraph">
    <p>Here are two examples of the Bootique standard modules:</p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p><code>bootique-jetty</code> that integrates Jetty server into your application</p></li>
     <li>
      <p><code>bootique-jdbc</code> that allows to work with relational databases</p></li>
    </ul>
   </div>
   <div class="paragraph">
    <p>It is helpful for you to think of your own code as being "organized into modules" as well. A simple custom module is shown below with an example of an object binding API that will be discussed later:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">public class MyModule implements BQModule {

    @Override
    public void configure(Binder binder) {
        binder.bind(MyService.class).to(MyServiceImpl.class);
    }
}</code></pre>
    </div>
   </div>
   <div class="admonitionblock note">
    <table>
     <tbody>
      <tr>
       <td class="icon"><i class="fa fa-info-circle fa-2x" title="Note"></i></td>
       <td class="content">By convention, all classes that logically belong to a module are packaged in a separate <code>.jar</code>. Though nothing prevents you from keeping multiple BQModules in a single <code>.jar</code>, or spreading your code across multiple jars. Other than autoloading descriptors explained below, there are no special packaging requirements for modules. They are all loaded into a single <code>BQRuntime</code>.</td>
      </tr>
     </tbody>
    </table>
   </div>
   <div class="admonitionblock note">
    <table>
     <tbody>
      <tr>
       <td class="icon"><i class="fa fa-info-circle fa-2x" title="Note"></i></td>
       <td class="content">Java Platform Module System (JPMS) is conceptually close to Bootique modules, and we would love to fully align the two. Unfortunately, it is our experience that forcing the users to adhere to JPMS everywhere would result in lots of limitations and invariable productivity loss, so we are intentionally ignoring possible JPMS synergies.</td>
      </tr>
     </tbody>
    </table>
   </div>
   <div class="sect3">
    <h4 id="modules_loading">2.1.1. Modules (Auto) Loading</h4>
    <div class="paragraph">
     <p>When a Bootique app is started, it loads object definitions from all modules it is aware of. Those can come from two places:</p>
    </div>
    <div class="ulist">
     <ul>
      <li>
       <p>Modules explicitly added to Bootique: <code>Bootique.app(args).module(MyModule.class)</code></p></li>
      <li>
       <p>"Auto-loadable" modules</p></li>
     </ul>
    </div>
    <div class="paragraph">
     <p>The first category is self-explanatory and allows to manually specify which modules should be in the app:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">Bootique.app()
        .module(JettyModule.class) <i class="conum" data-value="1"></i><b>(1)</b>
        .module(binder -&gt; binder.bind(MyService.class).to(MyServiceImpl.class)) <i class="conum" data-value="2"></i><b>(2)</b>
        .exec();</code></pre>
     </div>
    </div>
    <div class="colist arabic">
     <table>
      <tbody>
       <tr>
        <td><i class="conum" data-value="1"></i><b>1</b></td>
        <td>Adding a module by <code>BQModule</code> type</td>
       </tr>
       <tr>
        <td><i class="conum" data-value="2"></i><b>2</b></td>
        <td>Adding a module as a lambda</td>
       </tr>
      </tbody>
     </table>
    </div>
    <div class="paragraph">
     <p>The second category is modules that will be discovered automatically by looking for <code>META-INF/services/io.bootique.BQModule</code> files on the classpath, and getting the names of modules from those files:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">Bootique.app()
        .autoLoadModules() <i class="conum" data-value="1"></i><b>(1)</b>
        .module(binder -&gt; binder.bind(MyService.class).to(MyServiceImpl.class)) <i class="conum" data-value="2"></i><b>(2)</b>
        .exec();</code></pre>
     </div>
    </div>
    <div class="colist arabic">
     <table>
      <tbody>
       <tr>
        <td><i class="conum" data-value="1"></i><b>1</b></td>
        <td>Module auto-loading needs to be turned on explicitly</td>
       </tr>
       <tr>
        <td><i class="conum" data-value="2"></i><b>2</b></td>
        <td>Auto-loading can be combined with explicit modules</td>
       </tr>
      </tbody>
     </table>
    </div>
    <div class="paragraph">
     <p>In this example, instead of adding <code>JettyModule</code> explicitly, we turned on auto-loading allowing Bootique to locate and load this standard module (assuming it was added to the application as a dependency). When writing your own auto-loadable modules, you would add a line to <code>META-INF/services/io.bootique.BQModule</code>, containing the fully-qualified name of the BQModule Java class. E.g.:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-text text" data-lang="text">com.foo.MyModule</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>If you have more than one module in a given project, you should put all the names in this file, one per line. The result of autoloading, is that you can manage inclusion/exclusion of modules purely via the build system instead of in the code. Auto-loading is the recommended mechanism for assembling your app in almost all cases. All the standard Bootique modules are autoloadable.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_modules_metadata">2.1.2. Modules Metadata</h4>
    <div class="paragraph">
     <p><code>BQModule</code> has a method called <code>crate()</code> that you can optionally implement to expose module metadata to Bootique:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Override
public ModuleCrate crate() {
    return ModuleCrate.of(this)
            .description("Module that does something useful")
            .config("mymodulewithcrate", MyConfig.class)
            .build();
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>The returned "crate" can contain information about module configuration structure, its deprecation status, etc. While you can write modules without explicit "crates", providing a "crate" with as much information about the module as possible, would help Bootique to help your users (and your future self) to understand what the module does, and how to use it.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_deprecating_modules">2.1.3. Deprecating Modules</h4>
    <div class="paragraph">
     <p>TODO</p>
    </div>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_objects_assembly">2.2. Objects Assembly</h3>
   <div class="paragraph">
    <p>As mentioned above, <code>BQRuntime</code> is a holder of all application objects, and modules are blueprints to create those objects. You’d write your own module code to define how your objects should be created and initialized. This is done via bindings and "provider" methods, and with the assistance of the dependency injection (DI) mechanism built into Bootique.</p>
   </div>
   <div class="sect3">
    <h4 id="_dependency_injection">2.2.1. Dependency Injection</h4>
    <div class="paragraph">
     <p>Let’s start with how you can leverage DI when creating your objects. Objects can annotate their fields and/or constructors with <code>@Inject</code> to indicate which internal variables they want to be provided ("injected") by the Bootique DI environment. To demonstrate this, we will show a couple of implementations of a simple "hello" service that returns a greeting:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">public interface Hello {

    String sayHello();
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>An implementation of this service would need another service called <code>UserNameService</code> that returns a user name and needs to be injected. Here is a field injection flavor:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">public class HelloService1 implements Hello {

    @Inject
    private UserNameService nameService;

    @Override
    public String sayHello() {
        return "Hello, " + nameService.getUserName() + "!";
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>And here is a constructor flavor:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">public class HelloService2 implements Hello {

    private final UserNameService nameService;

    @Inject
    public HelloService2(UserNameService nameService) {
        this.nameService = nameService;
    }

    @Override
    public String sayHello() {
        return "Hello, " + nameService.getUserName() + "!";
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>Both flavors are identical in terms of functionality. Constructor variety is more verbose, but arguably results in a cleaner API, as the object can be created if needed without a DI environment.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_bindings">2.2.2. Bindings</h4>
    <div class="paragraph">
     <p>Regardless of which flavor was selected, the implementation needs to be <em>bound</em> in the module class:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Override
public void configure(Binder binder) {
    binder.bind(Hello.class)
            .to(HelloService2.class)
            .inSingletonScope();
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>This creates a permanent association between <code>Hello</code> interface and a specific implementation. <code>Hello</code> can now be injected into other services. A single instance of <code>HelloService2</code> is created automatically by the DI container, with a real object transparently provided for the "nameService".</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_provider_methods_in_modules">2.2.3. Provider Methods in Modules</h4>
    <div class="paragraph">
     <p>If the service construction requires additional assembly logic, you can create simple "provider" methods in the module class. Any method of a module class annotated with <code>@Provides</code> is treated a "provider" method. E.g.:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">public class HelloModule3 implements BQModule {

    @Singleton
    @Provides
    Hello provideHello(UserNameService nameService) {  <i class="conum" data-value="1"></i><b>(1)</b>
        return new HelloService3(nameService);
    }

    @Override
    public void configure(Binder binder) { <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
     </div>
    </div>
    <div class="colist arabic">
     <table>
      <tbody>
       <tr>
        <td><i class="conum" data-value="1"></i><b>1</b></td>
        <td>Provider method that does both assembly and binding of the Hello service.</td>
       </tr>
       <tr>
        <td><i class="conum" data-value="2"></i><b>2</b></td>
        <td><code>configure(..)</code> method may be empty, or contain other bindings</td>
       </tr>
      </tbody>
     </table>
    </div>
    <div class="paragraph">
     <p>What makes <code>provideHello</code> method a "provider" is the <code>@Provides</code> annotation. The access modifier is irrelevant (can be "public", "protected", etc.). The method does both assembly and binding of the "Hello" service. The return type (<code>Hello</code>) is used as the binding key. And while there is no <code>@Inject</code> annotation in use anywhere, injection in fact also happens here - all method arguments ("nameService" in this case) are injected by the DI environment.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_provider_objects">2.2.4. Provider Objects</h4>
    <div class="paragraph">
     <p>If more complex logic or lots of dependencies are required, instead of a provider method, you can create a provider class that implements <code>Provider&lt;MyService&gt;</code>. E.g.:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">public class HelloService3Provider implements Provider&lt;Hello&gt; {

    @Inject
    private UserNameService nameService;

    @Override
    public Hello get() {
        return new HelloService3(nameService);
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>It needs to be bound to an object declaration via <code>toProvider(..)</code> method;</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Override
public void configure(Binder binder) {
    binder.bind(Hello.class)
            .toProvider(HelloService3Provider.class)
            .inSingletonScope();
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>Provider object has the same rules for injection of its own dependencies as regular objects, i.e. either via annotated fields or an annotated constructor.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_injection_in_collections">2.2.5. Injection in Collections</h4>
    <div class="paragraph">
     <p>TODO</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_injection_and_generics">2.2.6. Injection and Generics</h4>
    <div class="paragraph">
     <p>TODO</p>
    </div>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_configuration">2.3. Configuration</h3>
   <div class="paragraph">
    <p>Bootique app can accept external configuration in different forms, coming from different sources. Internally, all configuration sources are combined following the rules described below into a single JSON-like tree object, that is used to initialize properties of some application objects.</p>
   </div>
   <div class="paragraph">
    <p>Common configuration formats are JSON or YAML. For simplicity, we’ll focus on YAML, but the two are interchangeable. Other sources are shell variables, Java properties and even cloud secrets managers. No matter which source (or combination of them) you use, all of them end up in a single tree object whose nodes match the structures of the application Java objects they will ultimately be converted to.</p>
   </div>
   <div class="paragraph">
    <p>Here is an example YAML file:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-yaml yaml" data-lang="yaml">log:
  level: warn
  appenders:
    - type: file
      logFormat: '%c{20}: %m%n'
      file: target/logback/debug.log

jetty:
  context: /myapp
  connectors:
    - port: 12009</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>By convention, the top-level keys correspond to the names of modules that use a given configuration. In the example above, <code>log</code> subtree configures <code>bootique-logback</code> module, while <code>jetty</code> configures <code>bootique-jetty</code>.</p>
   </div>
   <div class="admonitionblock note">
    <table>
     <tbody>
      <tr>
       <td class="icon"><i class="fa fa-info-circle fa-2x" title="Note"></i></td>
       <td class="content">For most standard modules, configuration formats are described in the module documentation. But each Bootique application contains a <code>-H</code> command that displays the full config structure for that app’s collection of modules. The output of this command is always the most accurate reference.</td>
      </tr>
     </tbody>
    </table>
   </div>
   <div class="sect3">
    <h4 id="_configuration_basics">2.3.1. Configuration Basics</h4>
    <div class="paragraph">
     <p>Consider the following YAML:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-yaml yaml" data-lang="yaml">my:
  intProperty: 55
  stringProperty: 'Hello, world!'</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>and the following object with matching property names:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@BQConfig <i class="conum" data-value="1"></i><b>(1)</b>
public class MyObject {

    final SomeOtherService soService;

    private int intProperty;
    private String stringProperty;

    @Inject
    public MyObject(SomeOtherService soService) {  <i class="conum" data-value="2"></i><b>(2)</b>
        this.soService = soService;
    }

    @BQConfigProperty <i class="conum" data-value="3"></i><b>(3)</b>
    public void setIntProperty(int i) {
        this.intProperty = i;
    }

    @BQConfigProperty <i class="conum" data-value="4"></i><b>(4)</b>
    public void setStringProperty(String s) {
        this.stringProperty = s;
    }

    public void doSomething() {
        // ..
    }
}</code></pre>
     </div>
    </div>
    <div class="colist arabic">
     <table>
      <tbody>
       <tr>
        <td><i class="conum" data-value="1"></i><b>1</b></td>
        <td>The optional <code>BQConfig</code> annotation helps to include this object in the output of the <code>-H</code> command</td>
       </tr>
       <tr>
        <td><i class="conum" data-value="2"></i><b>2</b></td>
        <td>Objects created from configuration can also inject any dependencies just like other Bootique objects</td>
       </tr>
       <tr>
        <td><i class="conum" data-value="3"></i><b>3</b></td>
        <td>A setter used to load <code>intProperty</code> into the object. The optional <code>BQConfigProperty</code> annotation ensures the property is included in the output of the <code>-H</code> command</td>
       </tr>
       <tr>
        <td><i class="conum" data-value="4"></i><b>4</b></td>
        <td>A setter used to load <code>stringProperty</code> into the object. The optional <code>BQConfigProperty</code> annotation ensures the property is included in the output of the <code>-H</code> command</td>
       </tr>
      </tbody>
     </table>
    </div>
    <div class="paragraph">
     <p>To create <code>MyObject</code> and load configuration values into it, we can use the following API:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Singleton
@Provides
public MyObject createMyService(ConfigurationFactory configFactory) {
    return configFactory.config(MyObject.class, "my");
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>In this example, <code>MyObject</code> obtains its properties separately from constructor injection and configuration. <code>ConfigurationFactory</code> is the object available in the core Bootique that holds the main config tree and serves as a factory for configuration-aware objects. The structure of <code>MyObject</code> is very simple, but it can be as complex as needed, containing nested objects, arrays, maps, etc. Internally Bootique uses Jackson framework to bind YAML/JSON to Java objects, so all the features of Jackson can be used to craft configuration.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_object_factories">2.3.2. Object Factories</h4>
    <div class="paragraph">
     <p>Very often configuration-aware objects are not retained by the app, but are created only to serve as <em>factories</em> of other objects, and then discarded. For instance, we can turn <code>MyObject</code> above into <code>MyFactory</code> that creates an object called <code>MyService</code>:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@BQConfig
public class MyFactory {

    private int intProperty;
    private String stringProperty;

    @BQConfigProperty
    public void setIntProperty(int i) {
        this.intProperty = i;
    }

    @BQConfigProperty
    public void setStringProperty(String s) {
        this.stringProperty = s;
    }

    // factory method
    public MyService createMyService(SomeOtherService soService) {
        return new MyServiceImpl(soService, intProperty, stringProperty);
    }
}</code></pre>
     </div>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Singleton
@Provides
public MyService provideMyService(
        ConfigurationFactory configFactory,
        SomeOtherService service) {

    return configFactory.config(MyFactory.class, "my").createMyService(service);
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>Also, here instead of injecting <code>SomeOtherService</code> into the factory, we injected it in the provider method. This is just another flavor. This is not specific to factories of course.</p>
    </div>
    <div class="admonitionblock note">
     <table>
      <tbody>
       <tr>
        <td class="icon"><i class="fa fa-info-circle fa-2x" title="Note"></i></td>
        <td class="content">All configuration-aware objects in Bootique standard modules are factories. We think this is the best pattern, and we recommend it to everyone, as it separates the actual application object from its configuration and factory code. This results in more "compact" and fully immutable objects. Though of course, the choice is ultimately left to the user.</td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_configuration_loading">2.3.3. Configuration Loading</h4>
    <div class="paragraph">
     <p>Configuration is multi-layered and can come from different sources:</p>
    </div>
    <div class="ulist">
     <ul>
      <li>
       <p>Config files (defined in the module code or passed on the command line)</p></li>
      <li>
       <p>Java properties</p></li>
      <li>
       <p>Environment variables</p></li>
      <li>
       <p>Cloud secrets managers</p></li>
      <li>
       <p>Custom configuration loaders</p></li>
     </ul>
    </div>
    <div class="paragraph">
     <p>The load sequence of the sources is roughly this: <em>(1) config files from modules → (2) config files from command line → (3) properties → (4) env variables</em>. The sources with the higher load order override values from the sources with the lower order.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_configuration_files_from_modules">2.3.4. Configuration Files from Modules</h4>
    <div class="paragraph">
     <p>One way to pass a config file to a Bootique app in the code.</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">BQCoreModule.extend(binder).addConfig("classpath:com/foo/default.yml");</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>Such configuration should be known at compile time and is usually embedded in the app, and referenced via the special <code>classpath:…​</code> URL. A primary motivation for this style is to provide application default configuration. More than one configuration can be contributed. Individual modules might load their own defaults independently of each other. The order of multiple configs loaded via this mechanism is undefined and should not be relied upon.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_configuration_files_from_cli">2.3.5. Configuration Files from CLI</h4>
    <div class="paragraph">
     <p>Config files can be specified on the command line with the <code>--config</code> option. It takes a file (or a URL) as a parameter. You can use <code>--config</code> multiple times to specify more than one file. The files will be loaded in the order of their appearance on the command line.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_configuration_properties">2.3.6. Configuration Properties</h4>
    <div class="paragraph">
     <p>YAML file can be thought of as a set of nested properties. E.g. the following config</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-yaml yaml" data-lang="yaml">my:
  prop1: val1
  prop2: val2</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>can be represented as two properties (<code>my.prop1</code>, <code>my.prop2</code>) that are assigned some values. Bootique takes advantage of this structural equivalence and allows to defined individual configuration values via Java properties. All configuration properties are prefixed with <code>bq.</code>. This "namespace" helps to avoid random naming conflicts with properties otherwise present in the system.</p>
    </div>
    <div class="paragraph">
     <p>Properties can be provided via <code>BQCoreModule</code> extender:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">class MyModule implements BQModule {
    public void configure(Binder binder) {

        BQCoreModule.extend(binder)
                .setProperty("bq.my.prop1", "valX")
                .setProperty("bq.my.prop2", "valY");
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>or come from system properties:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-bash bash" data-lang="bash">java -Dbq.my.prop1=valX -Dbq.my.prop2=valY -jar myapp.jar</code></pre>
     </div>
    </div>
    <div class="admonitionblock note">
     <table>
      <tbody>
       <tr>
        <td class="icon"><i class="fa fa-info-circle fa-2x" title="Note"></i></td>
        <td class="content">According to the Bootique authors' opinion, properties is the worst mechanism for app configuration, as there are so many better options. However, there is a common valid use case for them - building configurations dynamically in the code.</td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_configuration_environment_variables">2.3.7. Configuration Environment Variables</h4>
    <div class="paragraph">
     <p>Bootique allows to use <em>environment variables</em> to specify/override configuration values. Variables work similar to JVM properties, but have a number of advantages:</p>
    </div>
    <div class="ulist">
     <ul>
      <li>
       <p>Provide customized application environment without changing the launch script</p></li>
      <li>
       <p>A natural approach for CI/CD, container and cloud environments</p></li>
      <li>
       <p>Good for credentials. Unlike YAML, vars usually don’t end up in version control, and unlike Java properties, they are not visible in the process list</p></li>
      <li>
       <p>Appear explicitly in the app help</p></li>
     </ul>
    </div>
    <div class="paragraph">
     <p>To declare variables associated with configuration values, use the following API (notice that no <code>bq.</code> prefix is necessary here to identify the configuration value):</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">class MyModule implements BQModule {
    public void configure(Binder binder) {

        BQCoreModule.extend(binder)
                .declareVar("my.prop1", "P1")
                .declareVar("my.prop2", "P2");
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>So now a person running the app may set the above configuration as</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-bash bash" data-lang="bash">export P1=valX
export P2=valY</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>Moreover, explicitly declared vars will automatically appear in the application help, assisting the admins in configuring your app</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ java -jar myapp-1.0.jar --help
...
ENVIRONMENT
      P1
           Sets value of some property.

      P2
           Sets value of some other property.</code></pre>
     </div>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_cli_configuration_aliases">2.3.8. CLI Configuration Aliases</h4>
    <div class="paragraph">
     <p>It is possible to make fixed configuration inclusion conditional on the presence of a certain command line option:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">OptionMetadata o = OptionMetadata.builder("qa")
        .description("when present, uses QA config")
        .build();

BQCoreModule.extend(binder)
        .addOption(o)
        .mapConfigResource(o.getName(), "classpath:a/b/qa.yml");</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>Also, it is possible to link a single configuration value to a named CLI option:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">OptionMetadata o1 = OptionMetadata.builder("db")
        .description("specifies database URL")
        .valueOptionalWithDefault("jdbc:mysql://127.0.0.1:3306/mydb")
        .build();

BQCoreModule.extend(binder)
        .addOption(o1)
        .mapConfigPath(o1.getName(), "jdbc.mydb.url");</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>This adds a new <code>--db</code> option to the app that can be used to set JDBC URL of a datasource called "mydb". If value is not specified, the default one will be used.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_polymorphic_configuration_objects">2.3.9. Polymorphic Configuration Objects</h4>
    <div class="paragraph">
     <p>A powerful feature of Jackson is the ability to dynamically create subclasses of the configuration objects. Bootique takes full advantage of this. E.g. imagine a logging module that needs "appenders" to output its log messages (file appender, console appender, syslog appender, etc.). The framework might not be aware of all possible appenders its users might come up with in the future. Yet it still wants to have the ability to instantiate any of them, based solely on the data coming from YAML. Moreover, each appender will have its own set of incompatible configuration properties. In fact this is exactly the situation with <code>bootique-logback</code> module.</p>
    </div>
    <div class="paragraph">
     <p>Here is how you ensure that such a polymorphic configuration is possible. Let’s start with a simple class hierarchy:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">public abstract class BaseType {
    // ...
}

public class ConcreteType1 extends BaseType {
    // ...
}

public class ConcreteType2 extends BaseType {
    // ...
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>Now let’s create a matching set of factories to create one of the concrete subtypes of <code>BaseType</code>. Let’s use Jackson annotations to link specific types of symbolic names to be used in YAML below:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME,
        property = "type",
        defaultImpl = ConcreteTypeFactory1.class)
public abstract class BaseTypeFactory implements PolymorphicConfiguration {

    public abstract BaseType create();
}

@JsonTypeName("type1")
public class ConcreteTypeFactory1 extends BaseTypeFactory {

    @Override
    public BaseType create() {
        return new ConcreteType1();
    }
}

@JsonTypeName("type2")
public class ConcreteTypeFactory2 extends BaseTypeFactory {

    @Override
    public BaseType create() {
        return new ConcreteType2();
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>After that we need to create a service provider file called <code>META-INF/service/io.bootique.config.PolymorphicConfiguration</code> where all the types participating in the hierarchy are listed (including the supertype):</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-text text" data-lang="text">com.foo.BaseTypeFactory
com.foo.ConcreteTypeFactory1
com.foo.ConcreteTypeFactory2</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>This should be enough to work with configuration like this:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-yaml yaml" data-lang="yaml">my:
  type: type2
  someVar: someVal</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>The service of <code>BaseType</code> is bound in Bootique DI using the standard <code>ConfigurationFactory</code> approach described above. Depending on the YAML config, one of the subclasses of <code>BaseType</code> will be created:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Provides
public BaseType provideBaseType(ConfigurationFactory configFactory) {

    return configFactory
            .config(BaseTypeFactory.class, "my")
            .create();
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>If another module decides to create yet another subclass of BaseType, it will need to create its own <code>META-INF/service/io.bootique.config.PolymorphicConfiguration</code> file and add a new factory name there.</p>
    </div>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_commands">2.4. Commands</h3>
   <div class="paragraph">
    <p>Bootique runtime contains a set of commands coming from Bootique core and from all the modules currently in effect in the app. On startup Bootique attempts to map command-line arguments to a single command type. If no match is found, a <em>default</em> command is executed (which is normally a "help" command). To list all available commands, the app can be run with <code>--help</code> option (in most cases running without any options will have the same effect). E.g.:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ java -jar myapp-1.0.jar --help

NAME
      com.foo.MyApp

OPTIONS
      -c yaml_location, --config=yaml_location
           Specifies YAML config location, which can be a file path or a URL.

      -h, --help
           Prints this message.

      -H, --help-config
           Prints information about application modules and their configuration
           options.

      -s, --server
           Starts Jetty server.</code></pre>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_writing_commands">2.4.1. Writing Commands</h4>
    <div class="paragraph">
     <p>Most common commands are already available in various standard modules, still often you’d need to write your own. To do that, first create a command class. It should implement <code>io.bootique.command.Command</code> interface, though usually it more practical to extend <code>io.bootique.command.CommandWithMetadata</code> and provide some metadata used in help and elsewhere:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">public class MyCommand extends CommandWithMetadata {

    private static CommandMetadata createMetadata() {
        return CommandMetadata.builder(MyCommand.class)
                .description("My command does something important.")
                .build();
    }

    public MyCommand() {
        super(createMetadata());
    }

    @Override
    public CommandOutcome run(Cli cli) {

        // ... run the command here....

        return CommandOutcome.succeeded();
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>The command initializes metadata in constructor and implements the "run" method to run its code. The return CommandOutcome object instructs Bootique what to do when the command finishes. The object contains desired system exit code, and exceptions that occurred during execution. To make the new command available to Bootique, add it to `BQCoreModule’s extender, as was already shown above:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">public class MyModule implements BQModule {

    @Override
    public void configure(Binder binder) {
        BQCoreModule.extend(binder).addCommand(MyCommand.class);
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>To implement a "daemon" command running forever until it receives an OS signal (e.g. a web server waiting for user requests) , do something like this:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Override
public CommandOutcome run(Cli cli) {

    // ... start some process in a different thread ....

    // now wait till the app is stopped from another thread
    // or the JVM is terminated
    try {
        Thread.currentThread().join();
    } catch (InterruptedException e) {
        // ignore exception or log if needed
    }

    return CommandOutcome.succeeded();
}</code></pre>
     </div>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_injection_in_commands">2.4.2. Injection in Commands</h4>
    <div class="paragraph">
     <p>Commands can inject services, just like most other classes in Bootique. There are some specifics though. Since commands are sometimes instantiated, but not executed (e.g. when <code>--help</code> is run that lists all commands), it is often desirable to avoid immediate instantiation of all dependencies of a given command. So a common pattern with commands is to inject <code>javax.inject.Provider</code> instead of direct dependency:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Inject
private Provider&lt;SomeService&gt; provider;

@Override
public CommandOutcome run(Cli cli) {
    provider.get().someMethod();
}</code></pre>
     </div>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_decorating_commands">2.4.3. Decorating Commands</h4>
    <div class="paragraph">
     <p>Each command typically does a single well-defined thing, such as starting a web server, executing a job, etc. But very often in addition to that main thing you need to do other things. E.g. when a web server is started, you might also want to run a few more commands:</p>
    </div>
    <div class="ulist">
     <ul>
      <li>
       <p>Before starting the server, run a health check to verify that any external services the app might depend upon are alive.</p></li>
      <li>
       <p>Start a job scheduler in the background.</p></li>
      <li>
       <p>Start a monitoring "heartbeat" thread.</p></li>
     </ul>
    </div>
    <div class="paragraph">
     <p>To run all these "secondary" commands when the main command is invoked, Bootique provides command decorator API. First you create a decorator policy object that specifies one or more secondary commands and their invocation strategy (either <em>before</em> the main command, or <em>in parallel</em> with it). Second you "decorate" the main command with that policy:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">CommandDecorator extraCommands = CommandDecorator
        .beforeRun(CustomHealthcheckCommand.class)
        .alsoRun(ScheduleCommand.class)
        .alsoRun(HeartbeatCommand.class);

    BQCoreModule.extend(binder).decorateCommand(ServerCommand.class, extraCommands);</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>Based on the specified policy Bootique figures out the sequence of execution and runs the main and the secondary commands.</p>
    </div>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_options">2.5. Options</h3>
   <div class="sect3">
    <h4 id="_simple_options">2.5.1. Simple Options</h4>
    <div class="paragraph">
     <p>In addition to commands, the app can define "options". Options are not associated with any runnable java code, and simply pass command-line values to commands and services. E.g. the standard “--config” option is used to locate configuration file(s). Unrecognized options cause application startup errors. To be recognized, options need to be "contributed" to Bootique similar to commands:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">OptionMetadata option = OptionMetadata
        .builder("email", "An admin email address")
        .valueRequired("email_address")
        .build();

    BQCoreModule.extend(binder).addOption(option);</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>To read a value of the option, a service should inject <code>io.bootique.cli.Cli</code> object (commands also get this object as a parameter to "run") :</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Inject
private Cli cli;

public void doSomething() {
    Collection&lt;String&gt; emails = cli.optionStrings("email");
    // do something with option values....
}</code></pre>
     </div>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_configuration_options">2.5.2. Configuration Options</h4>
    <div class="paragraph">
     <p>While you can process your own options as described above, options often are just aliases to enable certain pieces of configuration. Bootique supports three flavors of associating options with configuration. Let’s demonstrate them here.</p>
    </div>
    <div class="olist arabic">
     <ol class="arabic">
      <li>
       <p>Option value sets a config property:</p>
       <div class="listingblock">
        <div class="content">
         <pre class="highlight"><code class="language-java java" data-lang="java">// Starting the app with "--my-opt=x" will set "jobs.myjob.param" value to "x"
BQCoreModule.extend(binder)
        .addOption(OptionMetadata.builder("my-opt").build())
        .mapConfigPath("my-opt", "jobs.myjob.param");</code></pre>
        </div>
       </div></li>
      <li>
       <p>Option presence sets a property to a predefined value:</p>
       <div class="listingblock">
        <div class="content">
         <pre class="highlight"><code class="language-java java" data-lang="java">// Starting the app with "--my-opt" will set "jobs.myjob.param" value to "y"
BQCoreModule.extend(binder)
        .addOption(OptionMetadata.builder("my-opt").valueOptionalWithDefault("y").build())
        .mapConfigPath("my-opt", "jobs.myjob.param");</code></pre>
        </div>
       </div></li>
      <li>
       <p>Option presence loads a config resource, such as a YAML file:</p>
       <div class="listingblock">
        <div class="content">
         <pre class="highlight"><code class="language-java java" data-lang="java">// Starting the app with "--my-opt" is equivalent to starting with "--config=classpath:xyz.yml"
BQCoreModule.extend(binder)
        .addOption(OptionMetadata.builder("my-opt").build())
        .mapConfigResource("my-opt", "classpath:xyz.yml");</code></pre>
        </div>
       </div></li>
     </ol>
    </div>
    <div class="paragraph">
     <p>The order of config-bound options on the command line is significant, just as the order of “--config” parameters. Bootique merges configuration associated with options from left to right, overriding any preceding configuration if there is an overlap.</p>
    </div>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_logging">2.6. Logging</h3>
   <div class="sect3">
    <h4 id="_loggers_in_the_code">2.6.1. Loggers in the Code</h4>
    <div class="paragraph">
     <p>Standard Bootique modules use <a href="https://www.slf4j.org/">SLF4J</a> internally, as it is the most convenient least common denominator framework, and can be easily bridged to other logging implementations. Your apps or modules are not required to use SLF4J, though if they do, it will likely reduce the amount of bridging needed to route all logs to a single destination.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_configurable_logging_with_logback">2.6.2. Configurable Logging with Logback</h4>
    <div class="paragraph">
     <p>For better control over logging a standard module called <code>bootique-logback</code> is available, that integrates <a href="https://logback.qos.ch/">Logback framework</a> in the app. It seamlessly bridges SLF4J (so you keep using SLF4J in the code), and allows to configure logging via YAML config file, including appenders (file, console, etc.) and per class/package log levels. Just like any other module, <code>bootique-logback</code> can be enabled by simply adding it to the pom.xml dependencies, assuming <code>autoLoadModules()</code> is in effect:</p>
    </div>
    <details open>
     <summary class="title">Maven</summary>
     <div class="content">
      <div class="listingblock">
       <div class="content">
        <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.bootique.logback&lt;/groupId&gt;
    &lt;artifactId&gt;bootique-logback&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
       </div>
      </div>
     </div>
    </details>
    <details>
     <summary class="title">Gradle</summary>
     <div class="content">
      <div class="listingblock">
       <div class="content">
        <pre class="highlight"><code class="language-groovy groovy" data-lang="groovy">{
  implementation: 'io.bootique.logback:bootique-logback'
}</code></pre>
       </div>
      </div>
     </div>
    </details>
    <div class="paragraph">
     <p>See <code>bootique-logback</code> module <a href="https://bootique.io/docs/3.x/bootique-logback-docs/">documentation</a> for further details.</p>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_bootlogger">2.6.3. BootLogger</h4>
    <div class="paragraph">
     <p>To perform logging during startup, before DI environment is available and YAML configuration is processed, Bootique uses a special service called <code>BootLogger</code>, that is not dependent on SLF4J and is not automatically bridged to Logback. It provides an abstraction for writing to stdout / stderr, as well as conditional "trace" logs sent to stderr. To enable Bootique trace logs, start the app with <code>-Dbq.trace</code> as described in the deployment section.</p>
    </div>
    <div class="paragraph">
     <p>BootLogger is injectable, in case your own code needs to use it. If the default BootLogger behavior is not satisfactory, it can be overridden right in the <code>main(..)</code> method, as unlike other services, you may need to change it before DI is available:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">public class Application {
    public static void main(String[] args) {
        Bootique.app(args).bootLogger(new MyBootLogger()).createRuntime().run();
    }
}</code></pre>
     </div>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="sect1">
 <h2 id="_testing">3. Testing</h2>
 <div class="sectionbody">
  <div class="sect2">
   <h3 id="_bootique_and_testing">3.1. Bootique and Testing</h3>
   <div class="paragraph">
    <p>Bootique is uniquely suitable to be used as a test framework. Within a single test it allows you to start and stop multiple in-process runtimes, each with а distinct set of modules and configurations. Bootique test facilities are controlled with a small number of annotations: <code>@BQTest</code>, <code>@BQTestTool</code> and <code>@BQApp</code>, that will be described below.</p>
   </div>
   <div class="paragraph">
    <p>This chapter is about the core test framework. For module-specific test APIs (e.g. <code>bootique-jdbc-junit5</code>, <code>bootique-jetty-junit5</code>), check documentation of those modules. They all follow the same base principles described here.</p>
   </div>
   <div class="paragraph">
    <p>To start using Bootique test extensions, import the following module in the "test" scope:</p>
   </div>
   <details open>
    <summary class="title">Maven</summary>
    <div class="content">
     <div class="listingblock">
      <div class="content">
       <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.bootique&lt;/groupId&gt;
    &lt;artifactId&gt;bootique-junit5&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
      </div>
     </div>
    </div>
   </details>
   <details>
    <summary class="title">Gradle</summary>
    <div class="content">
     <div class="listingblock">
      <div class="content">
       <pre class="highlight"><code class="language-groovy groovy" data-lang="groovy">{
  testImplementation: 'io.bootique:bootique-junit5'
}</code></pre>
      </div>
     </div>
    </div>
   </details>
   <div class="paragraph">
    <p>Each test class using Bootique extensions must be annotated with <code>@BQTest</code>:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">@BQTest
public class MyTest {
}</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>Doing that tells Bootique to manage lifecycle of test <code>BQRuntimes</code> and test "tools".</p>
   </div>
  </div>
  <div class="sect2">
   <h3 id="bqruntime">3.2. Test BQRuntimes</h3>
   <div class="paragraph">
    <p><code>BQRuntime</code> is an object representing an entire app (i.e. an object whose state and behavior you are checking in your test). You can declare <code>BQRuntime</code> as a static field of the test class, initialize it the way you would initialize an application (yes, using the same factory method from <code>Bootique</code> class), and annotate with <code>@BQApp</code> to let Bootique start and stop it when appropriate:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">@BQApp
final static BQRuntime app = Bootique
        .app("--server", "--config", "classpath:test.yml")
        .autoLoadModules()
        .createRuntime();</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>The "app" will be started by Bootique before all the tests in this class, and will be shutdown after all the tests are finished. You can declare any number of such "apps" within a test to emulate fairly complex systems. And as you can see in the example, you can pass any command or configuration as arguments to the <code>app(..)</code> method (that emulates a command-line invocation).</p>
   </div>
   <div class="paragraph">
    <p>Sometimes you just need a runtime instance, and do not want to execute any commands. For this case use <code>@BQApp(skipRun=true)</code>:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">@BQApp(skipRun = true)
final static BQRuntime app = Bootique
        .app("--config", "classpath:test.yml")
        .autoLoadModules()
        .createRuntime();</code></pre>
    </div>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_test_tools_and_scopes">3.3. Test Tools and Scopes</h3>
   <div class="paragraph">
    <p>Bootique provides a number of test tools that help you customize the apps for the test environment (e.g. <code>TcDbTester</code> tool from <code>bootique-jdbc-junit5-testcontainers</code> starts a test database and supplies a "module" to the app with DataSource configuration to access that DB; <code>JettyTester</code> from <code>bootique-jetty</code> configures HTTP connector to listen on a random unoccupied port and provides a Java client to send requests to the server, etc.).</p>
   </div>
   <div class="paragraph">
    <p>Tools are declared as fields in a test class, each annotated with <code>@BQTestTool</code>. A tool can exist in a certain scope (as defined by <code>@BQTestTool(value=…​)</code>. "Scope" determines when the tool is initialized and shutdown during the test. The following scopes are available:</p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p><code>BQTestScope.TEST_CLASS</code>: A scope of a single test class. Roughly corresponds to <code>@BeforeAll</code> / <code>@AfterAll</code> from JUnit. All tools in this scope must be declared as static variables.</p></li>
     <li>
      <p><code>BQTestScope.TEST_METHOD</code>: A scope of a single test method. Roughly corresponds to <code>@BeforeEach</code> / <code>@AfterEach</code> from JUnit.</p></li>
     <li>
      <p><code>BQTestScope.GLOBAL</code>: Allows a given tool to be shared with more than one test class. JUnit has no analog of a "global" scope, but it is quite useful for expensive reusable resources (e.g. Docker containers), so Bootique supports it for all the tools.</p></li>
     <li>
      <p><code>BQTestScope.IMPLIED</code>: This is the default scope of <code>@BQTestTool</code>. If the field is static it is equivalent to <code>TEST_CLASS</code>, if non-static - <code>TEST_METHOD</code>. This way most of the time you don’t need to explicitly define the scope, but just need to declare your tool as static or instance variable.</p></li>
    </ul>
   </div>
   <div class="paragraph">
    <p>Some examples:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">// implied scope is TEST_CLASS
@BQTestTool
final static MyTool tool1 = new MyTool();</code></pre>
    </div>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">// implied scope is TEST_METHOD
@BQTestTool
final MyTool tool2 = new MyTool();</code></pre>
    </div>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">// explicit GLOBAL scope. The variable must be static
@BQTestTool(value = BQTestScope.GLOBAL)
final static MyTool tool3 = new MyTool();</code></pre>
    </div>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_bqtestfactory_tool">3.4. BQTestFactory Tool</h3>
   <div class="paragraph">
    <p>A very common test tool is <code>BQTestFactory</code>. It allows to create and run <code>BQRuntimes</code> on the fly inside test class methods, and as such is a more flexible alternative to <code>@BQApp</code> annotation:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">@BQTestTool
final BQTestFactory testFactory = new BQTestFactory();</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p><code>BQTestFactory.app()</code> does roughly the same thing as <code>Bootique.app()</code>, with an important difference that all created runtimes will be automatically shut down at the end of the factory scope. E.g. in the following example <code>testFactory</code> would shut down any runtimes created in each test method right after that method finishes (since <code>testFactory</code> is an instance variable, the default scope is <code>TEST_METHOD</code>):</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void abc() {

    CommandOutcome result = testFactory.app("--server")
            // ensure all classpath modules are included
            .autoLoadModules()
            // add an adhoc module specific to the test
            .module(binder -&gt; binder.bind(MyService.class).to(MyServiceImpl.class))
            .run();
    // ...
}</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>If you need the runtime instance to poke inside the app’s DI container, you can call <code>createRuntime()</code> instead of <code>run()</code>:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void xyz() {

    BQRuntime app = testFactory.app("--server")
            .autoLoadModules()
            .createRuntime();
    // ...
}</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p><code>BQRuntime</code> of course has its own <code>run()</code> method, so you can both inspect the runtime and run a command.</p>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_common_test_scenarios">3.5. Common Test Scenarios</h3>
   <div class="paragraph">
    <p>Among the things that can be tested are runtime services with real dependencies, standard output of full Bootique applications (i.e. the stuff that would be printed to the console if this were a real app), network services using real network connections (e.g. your REST API’s), and so on. Some examples are given below, outlining the common techniques.</p>
   </div>
   <div class="sect3">
    <h4 id="_testing_injectable_services">3.5.1. Testing Injectable Services</h4>
    <div class="paragraph">
     <p>Services can be obtained from test runtime, their methods called, and assertions made about the results of the call:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@BQApp(skipRun = true)
static final BQRuntime app = Bootique
        .app("--config=src/test/resources/my.yml")
        .createRuntime();

@Test
public void service() {
    MyService service = app.getInstance(MyService.class);
    assertEquals("xyz", service.someMethod());
}</code></pre>
     </div>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_testing_network_services">3.5.2. Testing Network Services</h4>
    <div class="paragraph">
     <p>If a test command starts a web server or some other network service, it can be accessed via a URL right after running the server. E.g.:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">// a tool from "bootique-jetty-junit5". Doesn't require @BQTestTool,
// as it has no lifecycle of its own
static final JettyTester jetty = JettyTester.create();

@BQApp
static final BQRuntime app = Bootique
        .app("--server")
        .module(jetty.moduleReplacingConnectors())
        .createRuntime();

@Test
public void server() {
    Response response = jetty.getTarget().path("/somepath").request().get();
    JettyTester.assertOk(response);
}</code></pre>
     </div>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_testing_commands">3.5.3. Testing Commands</h4>
    <div class="paragraph">
     <p>You can run the app in the test and check the values of the exit code and <code>stdin</code> and <code>stderr</code> contents:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void command() {

    TestIO io = TestIO.noTrace();
    CommandOutcome outcome = testFactory
            .app("--help")
            .bootLogger(io.getBootLogger())
            .run();

    assertEquals(0, outcome.getExitCode());
    assertTrue(io.getStdout().contains("--help"));
    assertTrue(io.getStdout().contains("--config"));
}</code></pre>
     </div>
    </div>
   </div>
   <div class="sect3">
    <h4 id="_testing_module_validity">3.5.4. Testing Module Validity</h4>
    <div class="paragraph">
     <p>When you are writing your own modules, you may want to check that they are configured properly for autoloading (i.e. <code>META-INF/services/io.bootique.BQModule</code> is present in the expected place and contains the right provider), and their configuration is consistent. There’s a helper class to check for it:</p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void autoLoadable() {
    BQModuleTester.of(MyModule.class)
            .testAutoLoadable()
            .testConfig();
}</code></pre>
     </div>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="sect1">
 <h2 id="_assembly_and_deployment">4. Assembly and Deployment</h2>
 <div class="sectionbody">
  <div class="paragraph">
   <p>This chapter discusses how to package Bootique apps for deployment/distribution and how to run them. We are going to present two approaches that produce cross-platform runnable applications - "<a href="#runnable-jar-with-dependencies">Runnable Jar with Dependencies</a>" and "<a href="#runnable-jar-with-lib">Runnable Jar with "lib" Folder</a>". They only differ in how dependencies are packaged and referenced.</p>
  </div>
  <div class="paragraph">
   <p>Ultimately any Bootique app is just a Java app with the <code>main(..)</code> method and hence can be executed using <code>java</code> command. With that understanding you can come up with your own custom packaging strategies.</p>
  </div>
  <div class="sect2">
   <h3 id="runnable-jar-with-dependencies">4.1. Runnable Jar with Dependencies</h3>
   <div class="paragraph">
    <p>Under this approach application classes, resources and all classes and resources from dependency jars are packaged in a single "fat" runnable jar. In Maven this can be accomplished with <code>maven-shade-plugin</code>:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;build&gt;
    &lt;pluginManagement&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.5.3&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;createDependencyReducedPom&gt;true&lt;/createDependencyReducedPom&gt;
                    &lt;filters&gt;
                        &lt;filter&gt;
                            &lt;artifact&gt;*:*&lt;/artifact&gt;
                            &lt;excludes&gt;
                                &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;
                                &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;
                                &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;
                            &lt;/excludes&gt;
                        &lt;/filter&gt;
                    &lt;/filters&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;shade&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;transformers&gt;
                                &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" /&gt;
                                &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt;
                                    &lt;mainClass&gt;${main.class}&lt;/mainClass&gt;
                                &lt;/transformer&gt;
                                &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ApacheLicenseResourceTransformer"/&gt;
                                &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ApacheNoticeResourceTransformer"/&gt;
                            &lt;/transformers&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>Make sure you set the <code>main.class</code> property in the POM to the appropriate class value from your application or to <code>io.bootique.Bootique</code>:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;properties&gt;
    &lt;main.class&gt;com.foo.Application&lt;/main.class&gt;
&lt;/properties&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>Once the pom is configured, you can assemble and run the jar. E.g.:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">mvn clean package
java -jar target/myapp-1.0.jar</code></pre>
    </div>
   </div>
  </div>
  <div class="sect2">
   <h3 id="runnable-jar-with-lib">4.2. Runnable Jar with "lib" Folder</h3>
   <div class="paragraph">
    <p>"Jar-with-dependencies" packaging described above is extremely convenient. It produces a single file that is easy to move around and execute. It is not without downsides though:</p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p>It is incompatible with Java Platform Module System (JPMS). Java allows only one <code>module-info.class</code> file per <code>.jar</code>. So if your app or its dependencies contain one or more of those module descriptors, <code>maven-shade-plugin</code> won’t be able to package them properly.</p></li>
     <li>
      <p>It is incompatible with <a href="https://openjdk.java.net/jeps/238">multi-release jar files</a>. Actually there’s no technical reason why <code>maven-shade-plugin</code> can’t repackage such jars correctly, but as of this writing (plugin version 3.2.1) it doesn’t, losing Java version-specific code.</p></li>
    </ul>
   </div>
   <div class="paragraph">
    <p>An alternative way of packaging that does not have these limitations is a folder with a runnable application jar at the root level and all dependency jars in the <code>lib/</code> folder next to it:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code>my-app-1.0/
    # Runnable jar with classpath in MANIFEST.MF referencing "lib/*"
    my-app-1.0.jar
    # Dependencies folder
    lib/
        bootique-X.X.jar
        slf4j-api-1.7.25.jar
        ...</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>This folder is usually archived into a single <code>.tar.gz</code> or <code>.zip</code> file. It would then be unpacked on the machine where the application needs to run.</p>
   </div>
   <div class="paragraph">
    <p>Creating such packaging with Maven involves <code>maven-jar-plugin</code>, <code>maven-dependency-plugin</code> and <code>maven-assembly-plugin</code>. First let’s create the folder structure:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;properties&gt;
    &lt;main.class&gt;com.foo.Application&lt;/main.class&gt;
&lt;/properties&gt;
...
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;archive&gt;
                    &lt;manifest&gt;
                        &lt;mainClass&gt;${main.class}&lt;/mainClass&gt;
                        &lt;addClasspath&gt;true&lt;/addClasspath&gt;
                        &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
                        &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt;
                    &lt;/manifest&gt;
                &lt;/archive&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;includeScope&gt;runtime&lt;/includeScope&gt;
                &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;
            &lt;/configuration&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;assembly&lt;/id&gt;
                    &lt;phase&gt;prepare-package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;copy-dependencies&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>The above configuration places both main jar and "lib/" folder under <code>target/</code>, so you can build and run the app like this:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ mvn clean package
$ java -jar target/myapp-1.0.jar</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>To prepare the app for distribution as a single archive, you will need to add an assembly step. Start by creating an <code>assembly.xml</code> descriptor file:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;assembly xmlns="http://maven.apache.org/ASSEMBLY/2.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/ASSEMBLY/2.0.0 https://maven.apache.org/xsd/assembly-2.0.0.xsd"&gt;
    &lt;id&gt;tar.gz&lt;/id&gt;
    &lt;formats&gt;
        &lt;format&gt;tar.gz&lt;/format&gt;
    &lt;/formats&gt;
    &lt;fileSets&gt;
        &lt;fileSet&gt;
            &lt;directory&gt;${project.build.directory}&lt;/directory&gt;
            &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
            &lt;outputDirectory&gt;./&lt;/outputDirectory&gt;
            &lt;includes&gt;
                &lt;include&gt;${project.artifactId}-${project.version}.jar&lt;/include&gt;
                &lt;include&gt;lib/&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/fileSet&gt;
    &lt;/fileSets&gt;
&lt;/assembly&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>Now configure <code>maven-assembly-plugin</code>:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;
        &lt;descriptors&gt;
            &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt;
        &lt;/descriptors&gt;
        &lt;tarLongFileMode&gt;posix&lt;/tarLongFileMode&gt;
    &lt;/configuration&gt;
     &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;assembly&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>After you rerun packaging again, you should see <code>my-app-1.0.tar.gz</code> file in the <code>target</code> folder. This file can be sent to the end users or copied to your servers and unpacked there:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ mvn clean package
$ ls target/*.tar.gz

my-app-1.0.tar.gz</code></pre>
    </div>
   </div>
   <div class="admonitionblock note">
    <table>
     <tbody>
      <tr>
       <td class="icon"><i class="fa fa-info-circle fa-2x" title="Note"></i></td>
       <td class="content">An extra benefit of such packaging is that you can include any additional files with your application distro, such as installation instructions, custom startup scripts, licenses, etc. All of this is configured in <code>assembly.xml</code>.</td>
      </tr>
     </tbody>
    </table>
   </div>
  </div>
  <div class="sect2">
   <h3 id="_tracing_bootique_startup">4.3. Tracing Bootique Startup</h3>
   <div class="paragraph">
    <p>To see what modules are loaded, to view full app configuration tree and to trace other events that happen on startup, run your app with <code>-Dbq.trace</code> option. E.g.:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ java -Dbq.trace -jar target/myapp-1.0.jar --server</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>You may see an output like this:</p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlight"><code class="language-text text" data-lang="text">Skipping module 'JerseyModule' provided by 'JerseyModuleProvider' (already provided by 'Bootique')...
Adding module 'BQCoreModule' provided by 'Bootique'...
Adding module 'JerseyModule' provided by 'Bootique'...
Adding module 'JettyModule' provided by 'JettyModuleProvider'...
Adding module 'LogbackModule' provided by 'LogbackModuleProvider'...
Merged configuration: {"log":{"logFormat":"[%d{\"dd/MMM/yyyy:HH:mm:ss,SSS\"}]
%t %p %X{txid:-?} %X{principal:-?} %c{1}: %m%n%ex"},"trace":""}</code></pre>
    </div>
   </div>
   <div class="admonitionblock warning">
    <table>
     <tbody>
      <tr>
       <td class="icon"><i class="fa fa-exclamation-triangle fa-2x" title="Warning"></i></td>
       <td class="content">Printing configuration may expose sensitive information, like database passwords, etc. Make sure you use <code>-Dbq.trace</code> for debugging only and don’t leave it on permanently in a deployment environment.</td>
      </tr>
     </tbody>
    </table>
   </div>
  </div>
 </div>
</div>
        </article>
      </div>
    </div>
  </div>
</div>

<footer>
    <div id="footer-copy" class="container  d-flex flex-column align-items-center flex-lg-row flex-wrap justify-content-between  py-5 py-md-7">
    <ul class="list-inline nav-double  order-lg-3  mb-0">
        <li class="list-inline-item  mr-3 mr-lg-5">
            <a href="/docs/" class="text-uppercase">Documentation</a>
        </li>
        <li class="list-inline-item"><a href="/cla/" class="text-uppercase">CLA</a></li>
    </ul>
    <ul class="list-inline social-icons  order-lg-2  my-3 my-md-4 my-lg-0">
        <li class="list-inline-item  mr-4_5">
            <a href="https://github.com/bootique/bootique">
                <i class="fab fa-github"></i>
            </a>
        </li>
        <li class="list-inline-item  mr-4_5">
            <a href="https://twitter.com/BootiqueProject">
                <i class="fab fa-twitter"></i>
            </a>
        </li>
    </ul>
    <p class="order-lg-1  mb-0">&copy; <span class="current-year">2024</span> ObjectStyle LLC and individual authors</p>
</div>

</footer>


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-74603008-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-74603008-1');
</script>



<script>
!function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
},s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');

twq('init','nwf2s');
twq('track','PageView');
</script>


</body>
</html>

