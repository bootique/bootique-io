<!doctype html>
<html class="no-js" lang="en-us">
<head>
  <meta charset="utf-8">
  <title>Bootique: Minimally Opinionated Framework for Runnable Java</title>
  <meta name="description" content="Bootique: A Minimally Opinionated Framework for Runnable Java Apps">
<meta name="keywords" content="bootique, java, micro framework">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="manifest" href="/images/favicon/site.webmanifest">
  <link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#333333">
  <link rel="shortcut icon" href="/images/favicon/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-config" content="/images/favicon/browserconfig.xml">
  <meta name="theme-color" content="#333333">
  <link rel="canonical" href="https://bootique.io/docs/1.x/bootique-docs/">
  <link href="/assets/app.css?1b49aca56d4cc4fc79b0" rel="stylesheet">
<script type="text/javascript" src="/assets/app.js?1b49aca56d4cc4fc79b0"></script>

</head>

<body data-spy="scroll" data-target="#docs-nav">

<!--[if lt IE 10]>
<p class="browsehappy">
  You are using an <strong>outdated</strong> browser.
  Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.
</p>
<![endif]-->

<div id="top-nav" class="main">
  
  <a href="#menu" id="menuToggle" aria-label="Menu" class="menu-toggle">
      <span></span>
  </a>
  <div id="menu" class="nav-menu pure-menu pure-menu-horizontal">
    <a href="https://bootique.io/" class="nav-brand center"><img src="/images/logo.svg" alt="Bootique" /></a>
    <div class="container nav">
      <div class="valign-wrapper-sm">
        <div class="valign-sm">
          <ul class="pure-menu-list pull-left">
    
    
        <li class="pure-menu-item "><div class="">
            
              <a class="pure-menu-link" href="/docs/1.x/getting-started/">Get started</a>
            
            </div>
        </li>
  
        <li class="pure-menu-item "><div class="pure-menu-selected">
            <a class="pure-menu-link" href="/docs/1.x">Documentation</a>
          </div>
        </li>
  
        <li class="pure-menu-item ">
          <a class="pure-menu-link" href="/cla/">CLA</a>
        </li>
  
        <li class="pure-menu-item ">
          <a class="pure-menu-link" href="https://groups.google.com/forum/#!forum/bootique-user">Forum</a>
        </li>
  
</ul>

        </div>
      </div>
      <ul id="nav-social" class="pure-menu-list pull-right">
        <li class="pure-menu-item gh-btns" data-gh-owner="bootique" data-gh-repo="bootique">
          <a href="https://github.com/bootique/bootique" class="pure-menu-link github-btn fork">
            <i class="fab fa-github"></i><span>Github</span>
          </a>
          <a href="https://github.com/bootique/bootique/stargazers" class="pure-menu-link github-btn star">
            <img class="gh-stars" src="/images/icon_octocat_stars.svg" alt="GitHub Stars" />
            <span class="star-counter">1323</span>
          </a>
        </li>
        <li class="pure-menu-item tw-btn">
          <a href="https://twitter.com/intent/follow?screen_name=BootiqueProject" class="pure-menu-link tw-btn">
            <i class="fab fa-twitter"></i><span>Follow</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</div>


<div class="documentation-page container content docbook">
  <div class="container">
    <h1>
      Bootique Core Documentation
    </h1>
    <div class="dropdown doc-version">
  <a class="dropdown-toggle" href="#" id="dropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" data-offset="-24,4">
      Version 1.2
  </a>
  <div class="dropdown-menu" aria-labelledby="dropdownMenuLink">
          
              <a class="dropdown-item " href="/docs/2.x/bootique-docs/">Version 2.0 (alpha)</a>
          
          
              <a class="dropdown-item active" href="/docs/1.x/bootique-docs/">Version 1.2 (stable)</a>
          </div>
</div>

    <hr/>

    <div class="row ">
      <div id="docs-nav" class="col-12 col-lg-4 col-xl-3 nav  docs-nav"><div id="toc" class="toc"> 
 <div id="toctitle">
  Table of Contents
 </div> 
 <ul class="sectlevel1 nav"> 
  <li><a href="#_part_i_overview" class="nav-link">1. Part I. Overview</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#_what_is_bootique" class="nav-link">1.1. What is Bootique</a></li> 
    <li><a href="#_java_version" class="nav-link">1.2. Java Version</a></li> 
    <li><a href="#_build_system" class="nav-link">1.3. Build System</a></li> 
    <li><a href="#_programming_skills" class="nav-link">1.4. Programming Skills</a></li> 
   </ul> </li> 
  <li><a href="#_part_ii_programming" class="nav-link">2. Part II. Programming</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#_modules" class="nav-link">2.1. Modules</a></li> 
    <li><a href="#_modules_auto_loading" class="nav-link">2.2. Modules Auto-Loading</a></li> 
    <li><a href="#_configuration_and_configurable_factories" class="nav-link">2.3. Configuration and Configurable Factories</a></li> 
    <li><a href="#_using_modules" class="nav-link">2.4. Using Modules</a></li> 
    <li><a href="#_application_class" class="nav-link">2.5. Application Class</a></li> 
    <li><a href="#_commands" class="nav-link">2.6. Commands</a></li> 
    <li><a href="#_options" class="nav-link">2.7. Options</a></li> 
    <li><a href="#_logging" class="nav-link">2.8. Logging</a></li> 
   </ul> </li> 
  <li><a href="#_part_iii_testing" class="nav-link">3. Part III. Testing</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#_bootique_and_testing" class="nav-link">3.1. Bootique and Testing</a></li> 
    <li><a href="#_creating_test_runtimes" class="nav-link">3.2. Creating Test Runtimes</a></li> 
    <li><a href="#_common_test_scenarios" class="nav-link">3.3. Common Test Scenarios</a></li> 
   </ul> </li> 
  <li><a href="#_part_iv_assembly_and_deployment" class="nav-link">4. Part IV. Assembly and Deployment</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#runnable-jar-with-dependencies" class="nav-link">4.1. Runnable Jar with Dependencies</a></li> 
    <li><a href="#runnable-jar-with-lib" class="nav-link">4.2. Runnable Jar with "lib" Folder</a></li> 
    <li><a href="#_tracing_bootique_startup" class="nav-link">4.3. Tracing Bootique Startup</a></li> 
   </ul> </li> 
 </ul> 
</div></div>

      <div class="col-12 col-lg-8 col-xl-9  py-3 pl-lg-5">
        <article>
          <div class="sect1"> 
 <h2 id="_part_i_overview">1. Part I. Overview</h2> 
 <div class="sectionbody"> 
  <div class="sect2"> 
   <h3 id="_what_is_bootique">1.1. What is Bootique</h3> 
   <div class="paragraph"> 
    <p>Bootique is a minimally opinionated platform for building container-less runnable Java applications. No JavaEE container required to run your app! It is an ideal platform for <a href="http://martinfowler.com/articles/microservices.html"><em>microservices</em></a>, as it allows you to create a fully functional app with minimal-to-no setup. Though it is not limited to a specific kind of app (or the "micro" size) and can be used for REST services, webapps, runnable jobs, DB migrations, JavaFX GUI apps to mention a few examples.</p> 
   </div> 
   <div class="paragraph"> 
    <p>Unlike traditional container-based apps, Bootique allows you to control your <code>main()</code> method and create Java apps that behave like simple executable commands that can be run with Java:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">java -jar my.jar [arguments]</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>Each Bootique app can be started with a YAML configuration loaded from a file or from a remote URL. Among other benefits, such configuration approach ideally suits cloud deployment environments.</p> 
   </div> 
   <div class="paragraph"> 
    <p>Other popular products in this space are <a href="http://www.dropwizard.io/">Dropwizard</a> and <a href="http://projects.spring.io/spring-boot/">SpringBoot</a>, however Bootique’s focus is different. Bootique favors modularity and clean pluggable architecture. Bootique is built on top of <a href="https://github.com/google/guice">Google Guice</a> dependency injection (DI) container, which provides the core of its modularity mechanism. This means that pretty much anything in Bootique can be customized/overridden to your liking.</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_java_version">1.2. Java Version</h3> 
   <div class="paragraph"> 
    <p>Java 8 or newer is required.</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_build_system">1.3. Build System</h3> 
   <div class="paragraph"> 
    <p>Bootique apps can be built using any Java build system (Ant, Maven, Gradle, etc). Examples in the documentation are based on Maven.</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_programming_skills">1.4. Programming Skills</h3> 
   <div class="paragraph"> 
    <p>Everything you know about Java programming will be applicable when working with Bootique. You may need to "unlearn" some of the practices related to JavaEE configuration and container deployment though.</p> 
   </div> 
   <div class="paragraph"> 
    <p>Integration between various parts of a Bootique app is done via <a href="https://github.com/google/guice">Google Guice</a>. In most cases Bootique API would steer you towards idiomatic approach to integration, so deep knowledge of Guice is not required. Though it wouldn’t hurt to understand a few main concepts: modules, bindings, <a href="https://github.com/google/guice/wiki/Multibindings">multibindings</a>, <a href="http://google.github.io/guice/api-docs/latest/javadoc/index.html?com/google/inject/util/Modules.html">overrides</a>.</p> 
   </div> 
   <div class="paragraph"> 
    <p>Java <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">ServiceLoader</a> facility is another important part of Bootique, and probably yet another thing that you shouldn’t worry too much about initially.</p> 
   </div> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="_part_ii_programming">2. Part II. Programming</h2> 
 <div class="sectionbody"> 
  <div class="sect2"> 
   <h3 id="_modules">2.1. Modules</h3> 
   <div class="paragraph"> 
    <p>Bootique apps are made of "modules". The framework simply locates all available modules, loads them in the DI environment, parses the command line, and then transfers control to a Command (that can originate from any of the modules) that matched the user choice. There’s a growing list of modules created by Bootique development team. And you can easily write your own. In fact, programming in Bootique is primarily about writing Modules.</p> 
   </div> 
   <div class="paragraph"> 
    <p>A module is a Java library that contains some code. What makes it a module is a special Java class that implements <a href="https://google.github.io/guice/api-docs/latest/javadoc/index.html?com/google/inject/Module.html">Guice Module interface</a>. This class defines what "services" or other types of objects the module provides (in other words what will be injectable by the module users). This is done in a form of "bindings", i.e. associations between publicly visible injectable service interfaces and specific implementations:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-java java" data-lang="java">public class MyModule implements Module {
    @Override
    public void configure(Binder binder) {
        binder.bind(MyService.class).to(MyServiceImpl.class);
    }
}</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>There are other flavors of bindings in Guice. Please refer to <a href="https://github.com/google/guice/wiki/Motivation">Guice documentation</a> for details. One important form extensively used in Bootique is <a href="https://github.com/google/guice/wiki/Multibindings">Multibinding</a>.</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_modules_auto_loading">2.2. Modules Auto-Loading</h3> 
   <div class="paragraph"> 
    <p>Modules can be automatically loaded via <code>Bootique.autoLoadModules()</code> as long as they are included in your application dependencies. Auto-loading depends on the Java <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">ServiceLoader mechanism</a>. To ensure your modules can be auto-loaded do two things. First implement <code>io.bootique.BQModuleProvider</code> interface specific to your module:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-java java" data-lang="java">public class MyModuleProvider implements BQModuleProvider {
    @Override
    public Module module() {
        return new MyModule();
    }
}</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>After that create a file <code>META-INF/services/io.bootique.BQModuleProvider</code> with the only line being the name of your BQModuleProvider implementor. E.g.:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-text text" data-lang="text">com.foo.MyModuleProvider</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p><code>BQModuleProvider</code> has two more methods that you can optionally implement to help Bootique to make sense of the module being loaded:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-java java" data-lang="java">public class MyModuleProvider implements BQModuleProvider {
    // ...

    // provides human-readable name of the module
    @Override
    public String name() {
        return "CustomName";
    }

    // a collection of modules whose services are overridden by this module
    @Override
    public Collection&lt;Class&lt;? extends Module&gt;&gt; overrides() {
        return Collections.singleton(BQCoreModule.class);
    }
}</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>If in your Module you are planning to redefine any services from the upstream modules, specify those upstream modules in the <code>overrides()</code> collection. In practice overrides are rarely needed, and often can be replaced with service decomposition.</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_configuration_and_configurable_factories">2.3. Configuration and Configurable Factories</h3> 
   <div class="paragraph"> 
    <p>Bootique Modules obtain their configuration in a form of "factory objects". We’ll show some examples shortly. For now let’s focus on the big picture, namely the fact that Bootique app configuration is multi-layered and roughly follows the sequence of "code - config files (contributed) - config files (CLI) - overrides". "Code" is the default values that are provided in constructors of factory objects. Config files overlay those defaults with their own values. Config files can be either contributed in the code, or specified on the command line. Files is where the bulk of configuration usually stored. Finally config values may be further overridden via Java properties and/or environment variables.</p> 
   </div> 
   <div class="sect3"> 
    <h4 id="_configuration_via_yaml_files">2.3.1. Configuration via YAML Files</h4> 
    <div class="paragraph"> 
     <p>Format of configuration file can be either JSON or YAML. For simplicity we’ll focus on YAML format, but the two are interchangeable. Here is an example config file:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-yaml yaml" data-lang="yaml">log:
  level: warn
  appenders:
    - type: file
      logFormat: '%c{20}: %m%n'
      file: target/logback/debug.log

jetty:
  context: /myapp
  connectors:
    - port: 12009</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>While not strictly required, as a rule the top-level keys in the file belong to configuration objects of individual modules. In the example above "log" subtree configures <code>bootique-logback</code> module, while "jetty" subtree configures <code>bootique-jetty</code>. For standard modules refer to module-specific documentation on the structure of the supported configuration (or run your app <code>-H</code> flag to print supported config to the console). Here we’ll discuss how to build your own configuration-aware module.</p> 
    </div> 
    <div class="paragraph"> 
     <p>Bootique allows each Module to read its specific configuration subtree as an object of the type defined in the Module. Very often such an object is written as a factory that contains a bunch of setters for configuration properties, and a factory method to produce some "service" that a Module is interested in. Here is an example factory:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">public class MyFactory {

    private int intProperty;
    private String stringProperty;

    public void setIntProperty(int i) {
        this.intProperty = i;
    }

    public void setStringProperty(String s) {
        this.stringProperty = s;
    }

    // factory method
    public MyService createMyService(SomeOtherService soService) {
        return new MyServiceImpl(soService, intProperty, stringProperty);
    }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>The factory contains configuration property declarations, as well as public setters for these properties. (You may create getters as well. It is not required, but may be useful for unit tests, etc.). Now let’s take a look at the Module class:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">public class MyModule extends ConfigModule {

    @Singleton
    @Provides
    public MyService createMyService(
             ConfigurationFactory configFactory,
             SomeOtherService service) {

        return config(MyFactory.class, configFactory).createMyService(service);
    }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>A sample configuration that will work with our module may look like this:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-yaml yaml" data-lang="yaml">my:
  intProperty: 55
  stringProperty: 'Hello, world!'</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>A few points to note here:</p> 
    </div> 
    <div class="ulist"> 
     <ul> 
      <li> <p>Subclassing from <code>ConfigModule</code> is optional. <code>ConfigModule</code> provides a few utilities, such as a shorter "config" method and a default configuration key ("my" in this case. See the next bullet).</p> </li> 
      <li> <p>Calling our module "MyModule" and extending from <code>ConfigModule</code> gives it access to the protected "configPrefix" property that is initialized to the value of "my" based on the module class name. The naming convention here is to use the Module simple class name without the "Module" suffix and converted to lowercase.</p> </li> 
      <li> <p><code>@Provides</code> annotation is a Guice way of marking a Module method as a "provider" for a certain type of injectable service. All its parameters are themselves injectable objects.</p> </li> 
      <li> <p><code>ConfigurationFactory</code> is the class used to bind a subtree of the app YAML configuration to a given Java object (in our case - MyFactory). The structure of MyFactory is very simple here, but it can be as complex as needed, containing nested objects, arrays, maps, etc. Internally Bootique uses <a href="https://github.com/FasterXML/jackson">Jackson framework</a> to bind YAML to a Java class, so all the features of Jackson can be used to craft configuration.</p> </li> 
     </ul> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_configuration_file_loading">2.3.2. Configuration File Loading</h4> 
    <div class="paragraph"> 
     <p>A config file can be passed to a Bootique app via DI (those are usually coming from classpath) or on the command line:</p> 
    </div> 
    <div class="ulist"> 
     <ul> 
      <li> <p>Contributing a config file via DI:</p> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="highlight"><code class="language-java java" data-lang="java">BQCoreModule.extend(binder).addConfig("classpath:com/foo/default.yml");</code></pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>A primary motivation for this style is to provide application default configuration, with YAML files often embedded in the app and read from the classpath (as suggested by the "classpath:.." URL in the example). More then one configuration can be contributed. E.g. individual modules might load their own defaults. Multiple configs are combined in a single config tree by the runtime. The order in which this combination happens is undefined, so make sure there are no conflicts between them. If there are, consider replacing multiple conflicting configs with a single config.</p> 
       </div> </li> 
      <li> <p>Conditionally contributing a config file via DI. It is possible to make DI configuration inclusion conditional on the presence of a certain command line option:</p> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="highlight"><code class="language-java java" data-lang="java">OptionMetadata o = OptionMetadata.builder("qa")
      .description("when present, uses QA config")
      .build();

BQCoreModule.extend(binder)
      .addOption(o)
      .mapConfigResource(o.getName(), "classpath:a/b/qa.yml");</code></pre> 
        </div> 
       </div> </li> 
      <li> <p>Specifying a config file on the command line. Each Bootique app supports <code>--config</code> option that takes a configuration file as parameter. To specify more than one file, use <code>--config</code> option multiple times. Configurations will be loaded and merged together in the order of their appearance on the command line.</p> </li> 
      <li> <p>Specifying a single config value via a custom option:</p> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="highlight"><code class="language-java java" data-lang="java">OptionMetadata o = OptionMetadata.builder("db")
      .description("specifies database URL")
      .valueOptionalWithDefault("jdbc:mysql://127.0.0.1:3306/mydb")
      .build();

BQCoreModule.extend(binder)
      .addOption(o)
      .mapConfigPath(o.getName(), "jdbc.mydb.url);</code></pre> 
        </div> 
       </div> 
       <div class="paragraph"> 
        <p>This adds a new <code>--db</code> option to the app that can be used to set JDBC URL of a datasource called "mydb". If value is not specified, the default one will be used.</p> 
       </div> </li> 
     </ul> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_configuration_via_properties">2.3.3. Configuration via Properties</h4> 
    <div class="paragraph"> 
     <p>YAML file can be thought of as a set of nested properties. E.g. the following config</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-yaml yaml" data-lang="yaml">my:
  prop1: val1
  prop2: val2</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>can be represented as two properties ("my.prop1", "my.prop2") being assigned some values. Bootique takes advantage of this structural equivalence and allows to define configuration via properties as an alternative (or more frequently - an addition) to YAML. If the same "key" is defined in both YAML file and a property, <code>ConfigurationFactory</code> would use the value of the property (in other words properties override YAML values).</p> 
    </div> 
    <div class="paragraph"> 
     <p>To turn a given property into a configuration property, you need to prefix it with “bq.”. This "namespace" makes configuration explicit and helps to avoid random naming conflicts with properties otherwise present in the system.</p> 
    </div> 
    <div class="paragraph"> 
     <p>Properties can be provided to Bootique via BQCoreModule extender:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">class MyModule implements Module {
    public void configure(Binder binder) {

        BQCoreModule.extend(binder)
               .setProperty("bq.my.prop1", "valX")
               .setProperty("bq.my.prop2", "valY");
    }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>Alternatively they can be loaded from system properties. E.g.:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-bash bash" data-lang="bash">java -Dbq.my.prop1=valX -Dbq.my.prop2=valY -jar myapp.jar</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>Though generally this approach is sneered upon, as the authors of Bootique are striving to make Java apps look minimally "weird" in deployment, and "-D" is one of those unintuitive "Java-only" things. Often a better alternative is to define the bulk of configuration in YAML, and pass values for a few environment-specific properties via shell variables (see the next section) or bind them to CLI flags.</p> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_configuration_via_environment_variables">2.3.4. Configuration via Environment Variables</h4> 
    <div class="paragraph"> 
     <p>Bootique allows to use <em>environment variables</em> to specify/override configuration values. While variables work similar to JVM properties, using them has advantages in certain situations:</p> 
    </div> 
    <div class="ulist"> 
     <ul> 
      <li> <p>They may be used to configure credentials, as unlike YAML they won’t end up in version control, and unlike Java properties, they won’t be visible in the process list.</p> </li> 
      <li> <p>They provide customized application environment without changing the launch script and are ideal for containerized and other virtual environments.</p> </li> 
      <li> <p>They are more user-friendly and appear in the app help.</p> </li> 
     </ul> 
    </div> 
    <div class="paragraph"> 
     <p>To declare variables associated with configuration values, use the following API (notice that no "bq." prefix is necessary here to identify the configuration value):</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">class MyModule implements Module {
    public void configure(Binder binder) {

        BQCoreModule.extend(binder)
               .declareVar("my.prop1", "P1")
               .declareVar("my.prop2", "P2");
    }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>So now a person running the app may set the above configuration as</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-bash bash" data-lang="bash">export P1=valX
export P2=valY</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>Moreover, explicitly declared vars will automatically appear in the application help, assisting the admins in configuring your app</p> 
    </div> 
    <div class="paragraph"> 
     <p><em>(TODO: document BQConfig and BQConfigProperty config factory annotations required for the help generation to work)</em></p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ java -jar myapp-1.0.jar --help
...
ENVIRONMENT
      P1
           Sets value of some property.

      P2
           Sets value of some other property.</code></pre> 
     </div> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_polymorphic_configuration_objects">2.3.5. Polymorphic Configuration Objects</h4> 
    <div class="paragraph"> 
     <p>A powerful feature of Jackson is the ability to dynamically create subclasses of the configuration objects. Bootique takes full advantage of this. E.g. imagine a logging module that needs "appenders" to output its log messages (file appender, console appender, syslog appender, etc.). The framework might not be aware of all possible appenders its users might come up with in the future. Yet it still wants to have the ability to instantiate any of them, based solely on the data coming from YAML. Moreover each appender will have its own set of incompatible configuration properties. In fact this is exactly the situation with <code>bootique-logback</code> module.</p> 
    </div> 
    <div class="paragraph"> 
     <p>Here is how you ensure that such a polymorphic configuration is possible. Let’s start with a simple class hierarchy:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">public abstract class BaseType {
    // ...
}

public class ConcreteType1 extends BaseType {
    // ...
}

public class ConcreteType2 extends BaseType {
    // ...
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>Now let’s create a matching set of factories to create one of the concrete subtypes of <code>BaseType</code>. Let’s use Jackson annotations to link specific types of symbolic names to be used in YAML below:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME,
     property = "type",
     defaultImpl = ConcreteTypeFactory1.class)
public abstract class BaseTypeFactory implements PolymorphicConfiguration {

    public abstract BaseType create();
}

@JsonTypeName("type1")
public class ConcreteTypeFactory1 extends BaseTypeFactory {

     @Override
     public BaseType create() {
        return new ConcreteType1();
     }
}

@JsonTypeName("type2")
public class ConcreteTypeFactory2 extends BaseTypeFactory {

     @Override
     public BaseType create() {
        return new ConcreteType2();
     }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>After that we need to create a service provider file called <code>META-INF/service/io.bootique.config.PolymorphicConfiguration</code> where all the types participating in the hierarchy are listed (including the supertype):</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-text text" data-lang="text">com.foo.BaseTypeFactory
com.foo.ConcreteTypeFactory1
com.foo.ConcreteTypeFactory2</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>This should be enough to work with configuration like this:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-yaml yaml" data-lang="yaml">my:
  type: type2
  someVar: someVal</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>The service of <code>BaseType</code> is bound in Guice using the standard <code>ConfigurationFactory</code> approach described above. Depending on the YAML config, one of the subclasses of <code>BaseType</code> will be created:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">@Provides
public BaseType provideBaseType(ConfigurationFactory configFactory) {

    return configFactory
             .config(BaseTypeFactory.class, "my")
             .create();
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>If another module decides to create yet another subclass of BaseType, it will need to create its own <code>META-INF/service/io.bootique.config.PolymorphicConfiguration</code> file and add a new factory name there.</p> 
    </div> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_using_modules">2.4. Using Modules</h3> 
   <div class="paragraph"> 
    <p>Modules can use other "upstream" modules in a few ways:</p> 
   </div> 
   <div class="ulist"> 
    <ul> 
     <li> <p>"Import": a downstream module uses another module as a library, ignoring its injectable services.</p> </li> 
     <li> <p>"Use" : downstream module’s classes inject classes from an upstream module.</p> </li> 
     <li> <p>"Contribute": downstream module injects objects to collections and maps defined in upstream modules.</p> </li> 
    </ul> 
   </div> 
   <div class="paragraph"> 
    <p>Import case is trivial, so we’ll concentrate on the two remaining scenarios. We will use <a href="https://github.com/bootique/bootique/blob/master/bootique/src/main/java/io/bootique/BQCoreModule.java">BQCoreModule</a> as an example of an upstream module, as it is available in all apps.</p> 
   </div> 
   <div class="sect3"> 
    <h4 id="_injecting_other_modules_services">2.4.1. Injecting Other Module’s Services</h4> 
    <div class="paragraph"> 
     <p>You can inject any services declared in other modules. E.g. BQCoreModule provides a number of objects and services that can be accessed via injection:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">class MyService {

    @Args
    @Inject
    private String[] args;

    public String getArgsString() {
        return Arrays.asList(getArgs()).stream().collect(joining(" "));
    }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>In this example we injected command line arguments that were used to start the app. Note that since there can potentially be more than one <code>String[]</code> in a DI container, Bootique <code>@Args</code> annotation is used to uniquely identify the array that we want here.</p> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_contributing_to_other_modules">2.4.2. Contributing to Other Modules</h4> 
    <div class="paragraph"> 
     <p>Guice supports <a href="https://github.com/google/guice/wiki/Multibindings">multibindings</a>, intended to <em>contribute</em> objects defined in a downstream module to collections/maps used by services in upstream modules. Bootique hides Guice API complexities, usually providing "extenders" in each module. E.g. the following code adds <code>MyCommand</code> the the app set of commands:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">public class MyModule implements Module {

    @Override
    public void configure(Binder binder) {
        BQCoreModule.extend(binder).addCommand(MyCommand.class);
    }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>Here we obtained an extender instance via a static method on BQCoreModule. Most standard modules define their own extenders accessible via <code>"extend(Binder)"</code>. This is a pattern you might want to follow in your own modules.</p> 
    </div> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_application_class">2.5. Application Class</h3> 
   <div class="paragraph"> 
    <p>A class that contains the <code>"main()"</code> method is informally called "application". Bootique does not impose any additional requirements on this class. You decide what to put in it. It can be limited to just <code>"main()"</code>, or turned into a REST API resource, etc.</p> 
   </div> 
   <div class="sect3"> 
    <h4 id="_application_as_a_module">2.5.1. Application as a Module</h4> 
    <div class="paragraph"> 
     <p>Most often then not it makes sense to turn the application class into a Module though. After all a Bootique app is just a collection of Modules, and this way the application class would represent that one final Module to rule them all:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">public class Application implements Module {

   public static void main(String[] args) {
      Bootique.app(args).module(Application.class).autoLoadModules().exec().exit();
   }

   public void configure(Binder binder) {
      // load app-specific services; redefine standard ones
   }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>You may also implement a separate BQModuleProvider for the Application module. Then <code>autoLoadModules()</code> will discover it just like any other Module, and there won’t be a need to add Application module explicitly.</p> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_common_main_class">2.5.2. Common Main Class</h4> 
    <div class="paragraph"> 
     <p>If all your code is packaged in auto-loadable modules (which is always a good idea), you may not even need a custom main class. <code>io.bootique.Bootique</code> class itself declares a <code>main()</code> method and can be used as an app launcher. This creates some interesting possibilities. E.g. you can create Java projects that have no code of their own and are simply collections of modules declared as compile dependencies. More details on packaging are given in the "Runnable Jar" chapter.</p> 
    </div> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_commands">2.6. Commands</h3> 
   <div class="paragraph"> 
    <p>Bootique runtime contains a set of commands coming from Bootique core and from all the modules currently in effect in the app. On startup Bootique attempts to map command-line arguments to a single command type. If no match is found, a <em>default</em> command is executed (which is normally a "help" command). To list all available commands, the app can be run with <code>--help</code> option (in most cases running without any options will have the same effect). E.g.:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ java -jar myapp-1.0.jar --help

NAME
      com.foo.MyApp

OPTIONS
      -c yaml_location, --config=yaml_location
           Specifies YAML config location, which can be a file path or a URL.

      -h, --help
           Prints this message.

      -H, --help-config
           Prints information about application modules and their configuration
           options.

      -s, --server
           Starts Jetty server.</code></pre> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_writing_commands">2.6.1. Writing Commands</h4> 
    <div class="paragraph"> 
     <p>Most common commands are already available in various standard modules, still often you’d need to write your own. To do that, first create a command class. It should implement <code>io.bootique.command.Command</code> interface, though usually it more practical to extend <code>io.bootique.command.CommandWithMetadata</code> and provide some metadata used in help and elsewhere:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">public class MyCommand extends CommandWithMetadata {

    private static CommandMetadata createMetadata() {
        return CommandMetadata.builder(MyCommand.class)
                .description("My command does something important.")
                .build();
    }

    public MyCommand() {
        super(createMetadata());
    }

    @Override
    public CommandOutcome run(Cli cli) {

        // ... run the command here....

        return CommandOutcome.succeeded();
    }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>The command initializes metadata in constructor and implements the "run" method to run its code. The return CommandOutcome object instructs Bootique what to do when the command finishes. The object contains desired system exit code, and exceptions that occurred during execution. To make the new command available to Bootique, add it to `BQCoreModule’s extender, as was already shown above:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">public class MyModule implements Module {

    @Override
    public void configure(Binder binder) {
        BQCoreModule.extend(binder).addCommand(MyCommand.class);
    }
}</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>To implement a "daemon" command running forever until it receives an OS signal (e.g. a web server waiting for user requests) , do something like this:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">@Override
public CommandOutcome run(Cli cli) {

    // ... start some process in a different thread ....

    // now wait till the app is stopped from another thread
    // or the JVM is terminated
    try {
        Thread.currentThread().join();
    } catch (InterruptedException e) {
        // ignore exception or log if needed
    }

    return CommandOutcome.succeeded();
}</code></pre> 
     </div> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_injection_in_commands">2.6.2. Injection in Commands</h4> 
    <div class="paragraph"> 
     <p>Commands can inject services, just like most other classes in Bootique. There are some specifics though. Since commands are sometimes instantiated, but not executed (e.g. when <code>--help</code> is run that lists all commands), it is often desirable to avoid immediate instantiation of all dependencies of a given command. So a common pattern with commands is to inject Guice <code>Provider</code> instead of direct dependency:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">@Inject
private Provider&lt;SomeService&gt; provider;

@Override
public CommandOutcome run(Cli cli) {
    provider.get().someMethod();
}</code></pre> 
     </div> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_decorating_commands">2.6.3. Decorating Commands</h4> 
    <div class="paragraph"> 
     <p>Each command typically does a single well-defined thing, such as starting a web server, executing a job, etc. But very often in addition to that main thing you need to do other things. E.g. when a web server is started, you might also want to run a few more commands:</p> 
    </div> 
    <div class="ulist"> 
     <ul> 
      <li> <p>Before starting the server, run a health check to verify that any external services the app might depend upon are alive.</p> </li> 
      <li> <p>Start a job scheduler in the background.</p> </li> 
      <li> <p>Start a monitoring "heartbeat" thread.</p> </li> 
     </ul> 
    </div> 
    <div class="paragraph"> 
     <p>To run all these "secondary" commands when the main command is invoked, Bootique provides command decorator API. First you create a decorator policy object that specifies one or more secondary commands and their invocation strategy (either <em>before</em> the main command, or <em>in parallel</em> with it). Second you "decorate" the main command with that policy:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">CommandDecorator extraCommands = CommandDecorator
    .beforeRun(CustomHealthcheckCommand.class)
    .alsoRun(ScheduleCommand.class)
    .alsoRun(HeartbeatCommand.class);

BQCoreModule.extend(binder).decorateCommand(ServerCommand.class, extraCommands);</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>Based on the specified policy Bootique figures out the sequence of execution and runs the main and the secondary commands.</p> 
    </div> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_options">2.7. Options</h3> 
   <div class="sect3"> 
    <h4 id="_simple_options">2.7.1. Simple Options</h4> 
    <div class="paragraph"> 
     <p>In addition to commands, the app can define "options". Options are not associated with any runnable java code, and simply pass command-line values to commands and services. E.g. the standard “--config” option is used by <code>CliConfigurationSource</code> service to locate configuration file. Unrecognized options cause application startup errors. To be recognized, options need to be "contributed" to Bootique similar to commands:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">OptionMetadata option = OptionMetadata
    .builder("email", "An admin email address")
    .valueRequired("email_address")
    .build();

BQCoreModule.extend(binder).addOption(option);</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>To read a value of the option, a service should inject <code>io.bootique.cli.Cli</code> object (commands also get this object as a parameter to "run") :</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">@Inject
private Cli cli;

public void doSomething() {
    Collection&lt;String&gt; emails = cli.optionStrings("email");
    // do something with option values....
}</code></pre> 
     </div> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_configuration_options">2.7.2. Configuration Options</h4> 
    <div class="paragraph"> 
     <p>While you can process your own options as described above, options often are just aliases to enable certain pieces of configuration. Bootique supports three flavors of associating options with configuration. Let’s demonstrate them here.</p> 
    </div> 
    <div class="olist arabic"> 
     <ol class="arabic"> 
      <li> <p>Option value sets a config property:</p> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="highlight"><code class="language-java java" data-lang="java">// Starting the app with "--my-opt=x" will set "jobs.myjob.param" value to "x"
BQCoreModule.extend(binder)
        .addOption(OptionMetaData.builder("my-opt").build())
        .mapConfigPath("my-opt", "jobs.myjob.param");</code></pre> 
        </div> 
       </div> </li> 
      <li> <p>Option presence sets a property to a predefined value:</p> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="highlight"><code class="language-java java" data-lang="java">// Starting the app with "--my-opt" will set "jobs.myjob.param" value to "y"
BQCoreModule.extend(binder)
        .addOption(OptionMetaData.builder("my-opt").valueOptionalWithDefault("y").build())
        .mapConfigPath("my-opt", "jobs.myjob.param");</code></pre> 
        </div> 
       </div> </li> 
      <li> <p>Option presence loads a config resource, such as a YAML file:</p> 
       <div class="listingblock"> 
        <div class="content"> 
         <pre class="highlight"><code class="language-java java" data-lang="java">// Starting the app with "--my-opt" is equivalent to starting with "--config=classpath:xyz.yml"
BQCoreModule.extend(binder)
        .addOption(OptionMetaData.builder("my-opt").build())
        .mapConfigResource("my-opt", "classpath:xyz.yml");</code></pre> 
        </div> 
       </div> </li> 
     </ol> 
    </div> 
    <div class="paragraph"> 
     <p>The order of config-bound options on the command line is significant, just as the order of “--config” parameters. Bootique merges configuration associated with options from left to right, overriding any preceding configuration if there is an overlap.</p> 
    </div> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_logging">2.8. Logging</h3> 
   <div class="sect3"> 
    <h4 id="_loggers_in_the_code">2.8.1. Loggers in the Code</h4> 
    <div class="paragraph"> 
     <p>Standard Bootique modules use <a href="http://www.slf4j.org/">SLF4J</a> internally, as it is the most convenient least common denominator framework, and can be easily bridged to other logging implementations. Your apps or modules are not required to use SLF4J, though if they do, it will likely reduce the amount of bridging needed to route all logs to a single destination.</p> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_configurable_logging_with_logback">2.8.2. Configurable Logging with Logback</h4> 
    <div class="paragraph"> 
     <p>For better control over logging a standard module called <code>bootique-logback</code> is available, that integrates <a href="http://logback.qos.ch/">Logback framework</a> in the app. It seamlessly bridges SLF4J (so you keep using SLF4J in the code), and allows to configure logging via YAML config file, including appenders (file, console, etc.) and per class/package log levels. Just like any other module, <code>bootique-logback</code> can be enabled by simply adding it to the pom.xml dependencies, assuming <code>autoLoadModules()</code> is in effect:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.bootique.logback&lt;/groupId&gt;
    &lt;artifactId&gt;bootique-logback&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
     </div> 
    </div> 
    <div class="paragraph"> 
     <p>See <code>bootique-logback</code> module <a href="http://bootique.io/docs/0/bootique-logback-docs/">documentation</a> for further details.</p> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_bootlogger">2.8.3. BootLogger</h4> 
    <div class="paragraph"> 
     <p>To perform logging during startup, before DI environment is available and YAML configuration is processed, Bootique uses a special service called <code>BootLogger</code>, that is not dependent on SLF4J and is not automatically bridged to Logback. It provides an abstraction for writing to stdout / stderr, as well as conditional "trace" logs sent to stderr. To enable Bootique trace logs, start the app with <code>-Dbq.trace</code> as described in the deployment section.</p> 
    </div> 
    <div class="paragraph"> 
     <p>BootLogger is injectable, in case your own code needs to use it. If the default BootLogger behavior is not satisfactory, it can be overridden right in the <code>main(..)</code> method, as unlike other services, you may need to change it before DI is available:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">public class Application {
  public static void main(String[] args) {
     Bootique.app(args).bootLogger(new MyBootLogger()).run();
  }
}</code></pre> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="_part_iii_testing">3. Part III. Testing</h2> 
 <div class="sectionbody"> 
  <div class="sect2"> 
   <h3 id="_bootique_and_testing">3.1. Bootique and Testing</h3> 
   <div class="paragraph"> 
    <p>Bootique is uniquely suitable to be used as a test framework. Within a single test it allows you to start and stop multiple embedded Bootique runtimes, each with distinct set of modules and distinct YAML configurations, making it a powerful tool for <em>integration testing.</em></p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_creating_test_runtimes">3.2. Creating Test Runtimes</h3> 
   <div class="paragraph"> 
    <p>Here we’ll demonstrate the use of the core test framework. For module-specific test APIs (e.g. <code>bootique-jdbc-test</code>), check documentation of those modules or GitHub. To use the core framework, import the following module in the "test" scope:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.bootique&lt;/groupId&gt;
    &lt;artifactId&gt;bootique-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>Then create a <code>BQTestFactory</code> in each integration test, annotated with <code>@Rule</code> (or <code>@ClassRule</code> if you are planning to create a single runtime for all tests in a given class) :</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-java java" data-lang="java">public class MyTest {

    @Rule
    public BQTestFactory testFactory = new BQTestFactory();
}</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>Now use the factory to create test runtimes. Each runtime object is essentially an entire Bootique application. It can be used to inspect DI contents, execute a command (including commands that start background processes, such as <code>--server</code> and <code>--schedule</code>), etc. You don’t need to stop the runtime explicitly. <code>BQTestFactory</code> will take care of shutdown through JUnit lifecycle.</p> 
   </div> 
   <div class="paragraph"> 
    <p><code>testFactory.app()</code> returns a builder that mimics the API of <code>Bootique</code> class, with a few test-related extensions. E.g. it allows to load extra modules, etc.</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void testAbc() {

    BQRuntime runtime = testFactory.app()
        // ensure all classpath modules are included
        .autoLoadModules()
        // add an adhoc module specific to the test
        .module(binder -&gt; binder.bind(MyService.class).to(MyServiceImpl.class))
        .createRuntime();
    // ...
}</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>If you don’t need the runtime instance, but rather want to run a command, you’d call <code>run()</code> instead of <code>createRuntime()</code> (<code>run()</code> is an alias for <code>createRuntime().run()</code>):</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void testAbc() {

    CommandOutcome result = testFactory.app("--server")
        .autoLoadModules()
        .run();
    // ...
}</code></pre> 
    </div> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_common_test_scenarios">3.3. Common Test Scenarios</h3> 
   <div class="paragraph"> 
    <p>Among the things that can be tested are runtime services with real dependencies, standard output of full Bootique applications (i.e. the stuff that would be printed to the console if this were a real app), network services using real network connections (e.g. your REST API’s), and so on. Some examples are given below, outlining common techniques.</p> 
   </div> 
   <div class="sect3"> 
    <h4 id="_testing_injectable_services">3.3.1. Testing Injectable Services</h4> 
    <div class="paragraph"> 
     <p>Services can be obtained from test runtime, their methods called, and assertions made about the results of the call:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void testService() {

    BQRuntime runtime = testFactory.app("--config=src/test/resources/my.yml").createRuntime();

    MyService service = runtime.getInstance(MyService.class);
    assertEquals("xyz", service.someMethod());
}</code></pre> 
     </div> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_testing_network_services">3.3.2. Testing Network Services</h4> 
    <div class="paragraph"> 
     <p>If a test command starts a web server or some other network service, it can be accessed via a URL right after running the server. E.g.:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void testServer() {

    testFactory.app("--server").run();

    // using JAX-RS client API
    WebTarget base = ClientBuilder.newClient().target("http://localhost:8080/");
    Response r1 = base.path("/somepath").request().get();
    assertEquals(Status.OK.getStatusCode(), r1.getStatus());
    assertEquals("{}", r1.readEntity(String.class));
}</code></pre> 
     </div> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_testing_commands">3.3.3. Testing Commands</h4> 
    <div class="paragraph"> 
     <p>You can emulate a real app execution in a unit test, by running a command and then checking the values of the exist code and <code>stdin</code> and <code>stderr</code> contents:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void testCommand() {

    TestIO io = TestIO.noTrace();
    CommandOutcome outcome = testFactory
        .app("--help")
        .bootLogger(io.getBootLogger())
        .run();

    assertEquals(0, outcome.getExitCode());
    assertTrue(io.getStdout().contains("--help"));
    assertTrue(io.getStdout().contains("--config"));
}</code></pre> 
     </div> 
    </div> 
   </div> 
   <div class="sect3"> 
    <h4 id="_testing_module_validity">3.3.4. Testing Module Validity</h4> 
    <div class="paragraph"> 
     <p>When you are writing your own modules, you may want to check that they are configured properly for autoloading (i.e. <code>META-INF/services/io.bootique.BQModuleProvider</code> is present in the expected place and contains the right provider. There’s a helper class to check for it:</p> 
    </div> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="highlight"><code class="language-java java" data-lang="java">@Test
public void testAutoLoadable() {
    BQModuleProviderChecker.testAutoLoadable(MyModuleProvider.class);
}</code></pre> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="_part_iv_assembly_and_deployment">4. Part IV. Assembly and Deployment</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>This chapter discusses how to package Bootique apps for deployment/distribution and how to run them. We are going to present two approaches that produce cross-platform runnable applications - "<a href="#runnable-jar-with-dependencies">Runnable Jar with Dependencies</a>" and "<a href="#runnable-jar-with-lib">Runnable Jar with "lib" Folder</a>". They only differ in how dependencies are packaged and referenced.</p> 
  </div> 
  <div class="paragraph"> 
   <p>Ultimately any Bootique app is just a Java app with a <code>main(..)</code> method and hence can be executed using <code>java</code> command. With that understanding you can come up with your own custom packaging strategies.</p> 
  </div> 
  <div class="sect2"> 
   <h3 id="runnable-jar-with-dependencies">4.1. Runnable Jar with Dependencies</h3> 
   <div class="paragraph"> 
    <p>Under this approach application classes, resources and all classes and resources from dependency jars are packaged in a single "fat" runnable jar. In Maven this can be accomplished with <code>maven-shade-plugin</code>. To simplify plugin configuration, your app <code>pom.xml</code> may inherit from <code>bootique-parent</code> pom. Then configuration would look like this:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;parent&gt;
    &lt;groupId&gt;io.bootique.parent&lt;/groupId&gt;
    &lt;artifactId&gt;bootique-parent&lt;/artifactId&gt;
    &lt;version&gt;0.14&lt;/version&gt;
&lt;/parent&gt;

...
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>It will create the app with the framework-provided main class <code>io.bootique.Bootique</code>. You can set Maven <code>main.class</code> property, to use your own main class instead:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;properties&gt;
    &lt;main.class&gt;com.foo.Application&lt;/main.class&gt;
&lt;/properties&gt;</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>If you don’t want to inherit from the framework pom, you will need to add the following (fairly long) piece of configuration to your <code>pom.xml</code>:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.2.1&lt;/version&gt;

    &lt;configuration&gt;
        &lt;createDependencyReducedPom&gt;true&lt;/createDependencyReducedPom&gt;
        &lt;filters&gt;
            &lt;filter&gt;
                &lt;artifact&gt;*:*&lt;/artifact&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;
                    &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;
                    &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;
                &lt;/excludes&gt;
            &lt;/filter&gt;
        &lt;/filters&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;shade&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;transformers&gt;
                    &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" /&gt;
                    &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt;
                        &lt;mainClass&gt;${main.class}&lt;/mainClass&gt;
                    &lt;/transformer&gt;
                &lt;/transformers&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>Either way, once the pom is configured, you can assemble and run the jar. E.g.:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">mvn clean package
java -jar target/myapp-1.0.jar</code></pre> 
    </div> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="runnable-jar-with-lib">4.2. Runnable Jar with "lib" Folder</h3> 
   <div class="paragraph"> 
    <p>"Jar-with-dependencies" packaging described above is extremely convenient. It produces a single file that is easy to move around and execute. It is not without downsides though:</p> 
   </div> 
   <div class="ulist"> 
    <ul> 
     <li> <p>It is incompatible with Java Platform Module System (JPMS). Java allows only one <code>module-info.class</code> file per <code>.jar</code>. So if your app or its dependencies contain one or more of those module descriptors, <code>maven-shade-plugin</code> won’t be able to package them properly.</p> </li> 
     <li> <p>It is incompatible with <a href="https://openjdk.java.net/jeps/238">multi-release jar files</a>. Actually there’s no technical reason why <code>maven-shade-plugin</code> can’t repackage such jars correctly, but as of this writing (plugin version 3.2.1) it doesn’t, losing Java version-specific code.</p> </li> 
    </ul> 
   </div> 
   <div class="paragraph"> 
    <p>An alternative way of packaging that does not have these limitations is a folder with a runnable application jar at the root level and all dependency jars in the <code>lib/</code> folder next to it:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code>my-app-1.0/
    # Runnable jar with classpath in MANIFEST.MF referencing "lib/*"
    my-app-1.0.jar
    # Dependencies folder
    lib/
        bootique-X.X.jar
        slf4j-api-1.7.25.jar
        ...</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>This folder is usually archived into a single <code>.tar.gz</code> or <code>.zip</code> file. It would then be unpacked on the machine where the application needs to run.</p> 
   </div> 
   <div class="paragraph"> 
    <p>Creating such packaging with Maven involves <code>maven-jar-plugin</code>, <code>maven-dependency-plugin</code> and <code>maven-assembly-plugin</code>. First let’s create the folder structure:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;properties&gt;
    &lt;main.class&gt;com.foo.Application&lt;/main.class&gt;
&lt;/properties&gt;
...
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;archive&gt;
                    &lt;manifest&gt;
                        &lt;mainClass&gt;${main.class}&lt;/mainClass&gt;
                        &lt;addClasspath&gt;true&lt;/addClasspath&gt;
                        &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
                        &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt;
                    &lt;/manifest&gt;
                &lt;/archive&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;assembly&lt;/id&gt;
                    &lt;phase&gt;prepare-package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;copy-dependencies&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
            &lt;configuration&gt;
                &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>The above configuration places both main jar and "lib/" folder under <code>target/</code>, so you can build and run the app like this:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ mvn clean package
$ java -jar target/myapp-1.0.jar</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>To prepare the app for distribution as a single archive, you will need to add an assembly step. Start by creating an <code>assembly.xml</code> descriptor file:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;assembly xmlns="http://maven.apache.org/ASSEMBLY/2.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/ASSEMBLY/2.0.0 https://maven.apache.org/xsd/assembly-2.0.0.xsd"&gt;
    &lt;id&gt;tar.gz&lt;/id&gt;
    &lt;formats&gt;
        &lt;format&gt;tar.gz&lt;/format&gt;
    &lt;/formats&gt;
    &lt;fileSets&gt;
        &lt;fileSet&gt;
            &lt;directory&gt;${project.build.directory}&lt;/directory&gt;
            &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
            &lt;outputDirectory&gt;./&lt;/outputDirectory&gt;
            &lt;includes&gt;
                &lt;include&gt;${project.artifactId}-${project.version}.jar&lt;/include&gt;
                &lt;include&gt;lib/&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/fileSet&gt;
    &lt;/fileSets&gt;
&lt;/assembly&gt;</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>Now configure <code>maven-assembly-plugin</code>:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-xml xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;
        &lt;descriptors&gt;
            &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt;
        &lt;/descriptors&gt;
        &lt;tarLongFileMode&gt;posix&lt;/tarLongFileMode&gt;
    &lt;/configuration&gt;
     &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;assembly&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>After you rerun packaging again, you should see <code>my-app-1.0.tar.gz</code> file in the <code>target</code> folder. This file can be sent to the end users or copied to your servers and unpacked there:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ mvn clean package
$ ls target/*.tar.gz

my-app-1.0.tar.gz</code></pre> 
    </div> 
   </div> 
   <div class="admonitionblock note"> 
    <table> 
     <tbody>
      <tr> 
       <td class="icon"> <i class="fa fa-info-circle fa-2x" title="Note"></i> </td> 
       <td class="content"> An extra benefit of such packaging is that you can include any additional files with your application distro, such as installation instructions, custom startup scripts, licenses, etc. All of this is configured in <code>assembly.xml</code>. </td> 
      </tr> 
     </tbody>
    </table> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="_tracing_bootique_startup">4.3. Tracing Bootique Startup</h3> 
   <div class="paragraph"> 
    <p>To see what modules are loaded, to view full app configuration tree and to trace other events that happen on startup, run your app with <code>-Dbq.trace</code> option. E.g.:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-bash bash" data-lang="bash">$ java -Dbq.trace -jar target/myapp-1.0.jar --server</code></pre> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>You may see an output like this:</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-text text" data-lang="text">Skipping module 'JerseyModule' provided by 'JerseyModuleProvider' (already provided by 'Bootique')...
Adding module 'BQCoreModule' provided by 'Bootique'...
Adding module 'JerseyModule' provided by 'Bootique'...
Adding module 'JettyModule' provided by 'JettyModuleProvider'...
Adding module 'LogbackModule' provided by 'LogbackModuleProvider'...
Merged configuration: {"log":{"logFormat":"[%d{\"dd/MMM/yyyy:HH:mm:ss,SSS\"}]
%t %p %X{txid:-?} %X{principal:-?} %c{1}: %m%n%ex"},"trace":""}</code></pre> 
    </div> 
   </div> 
   <div class="admonitionblock caution"> 
    <table> 
     <tbody>
      <tr> 
       <td class="icon"> <i class="fa fa-exclamation-triangle fa-2x" title="Caution"></i> </td> 
       <td class="content"> Printing configuration may expose sensitive information, like database passwords, etc. Make sure you use <code>-Dbq.trace</code> for debugging only and don’t leave it on permanently in a deployment environment. </td> 
      </tr> 
     </tbody>
    </table> 
   </div> 
  </div> 
 </div> 
</div>
        </article>
      </div>
    </div>
  </div>
</div>

<footer>
    <div id="footer-copy" class="container  d-flex flex-column align-items-center flex-lg-row flex-wrap justify-content-between  py-5 py-md-7">
    <ul class="list-inline nav-double  order-lg-3  mb-0">
        <li class="list-inline-item  mr-3 mr-lg-5">
            <a href="/docs/" class="text-uppercase">Documentation</a>
        </li>
        <li class="list-inline-item  mr-3 mr-lg-5">
            <a href="https://blog.bootique.io/" class="text-uppercase">Blog</a>
        </li>
        <li class="list-inline-item"><a href="/cla/" class="text-uppercase">CLA</a></li>
    </ul>
    <ul class="list-inline social-icons  order-lg-2  my-3 my-md-4 my-lg-0">
        <li class="list-inline-item  mr-4_5">
            <a href="https://github.com/bootique/bootique">
                <i class="fab fa-github"></i>
            </a>
        </li>
        <li class="list-inline-item  mr-4_5">
            <a href="https://twitter.com/BootiqueProject">
                <i class="fab fa-twitter"></i>
            </a>
        </li>
        <li class="list-inline-item">
            <a href="https://blog.bootique.io/">
                <i class="fab fa-medium-m"></i>
            </a>
        </li>
    </ul>
    <p class="order-lg-1  mb-0">&copy; <span class="current-year">2021</span> ObjectStyle LLC and individual authors</p>
</div>

</footer>


<script>
  (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
  function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
  e=o.createElement(i);r=o.getElementsByTagName(i)[0];
  e.src='https://www.google-analytics.com/analytics.js';
  r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
  ga('create','UA-74603008-1');ga('send','pageview');
</script>



<script>
!function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
},s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');

twq('init','nwf2s');
twq('track','PageView');
</script>


</body>
</html>

